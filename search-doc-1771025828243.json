{"searchDocs":[{"title":"Group","type":0,"sectionRef":"#","url":"/QuickZone/api/Group","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#functions","content":" ","version":null,"tagName":"h2"},{"title":"add​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#add","content":"&lt;/&gt; Group:add( entity: Entity,-- The object to track. metadata: any?-- Optional data passed to Observer callbacks. ) → Group Adds an entity to the group. If the entity is already in another group, it is automatically removed from the old one first. Example: Adding Different Entity Types local myGroup = QuickZone.Group() -- Adding a BasePart myGroup:add(workspace.Part) -- Adding a Model with custom metadata myGroup:add(workspace.NPCModel, { Type = 'Enemy', Level = 42 }) -- Adding a custom table local spell = { CFrame = CFrame.new(0, 10, 0), Name = 'Fireball' } myGroup:add(spell) Strategy Detection QuickZone automatically determines how to track the entity's position: BasePart: Uses Position Model: Uses PrimaryPart.Position or GetPivot() Attachment/Bone: Uses WorldPosition Table: Looks for .Position, .CFrame, .WorldPosition, or :GetPivot().  ","version":null,"tagName":"h3"},{"title":"remove​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#remove","content":"&lt;/&gt; Group:remove( ...: Entity-- The entities to stop tracking. ) → Group Removes one or more entities from the group. -- Single removal myGroup:remove(workspace.Part) -- Multiple removal in one call myGroup:remove(partA, partB, modelC, spellTable)   ","version":null,"tagName":"h3"},{"title":"contains​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#contains","content":"&lt;/&gt; Group:contains(entity: Entity) → boolean Checks if a specific entity is currently a member of this group.  ","version":null,"tagName":"h3"},{"title":"setConfig​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#setConfig","content":"&lt;/&gt; Group:setConfig(config: { updateRate: number?, precision: number?, safety: boolean? }) → Group Updates the group's configuration. Precision A higher precision value (e.g., 2.0) means entities must move further before a re-calculation is triggered, improving performance for large groups.  ","version":null,"tagName":"h3"},{"title":"getConfig​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getConfig","content":"&lt;/&gt; Group:getConfig() → { updateRate: number, precision: number, safety: boolean } Returns the current configuration settings for this group. local config = myGroup:getConfig() print('Update Rate: ' .. config.updateRate .. 'Hz')   ","version":null,"tagName":"h3"},{"title":"getId​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getId","content":"&lt;/&gt; Group:getId() → number Returns the unique internal ID of this group.  ","version":null,"tagName":"h3"},{"title":"getEntities​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getEntities","content":"&lt;/&gt; Group:getEntities() → {Entity} Returns a list of all entities currently belonging to this group.  ","version":null,"tagName":"h3"},{"title":"getObservers​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getObservers","content":"&lt;/&gt; Group:getObservers() → {Observer} Returns a list of all Observers currently watching this group. local observers = myGroup:getObservers() print('This group is being watched by ' .. #observers .. ' observers.')   ","version":null,"tagName":"h3"},{"title":"destroy​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#destroy","content":"Destructor &lt;/&gt; Group:destroy() → () Cleans up the group, removes all tracked entities, and detaches any associated observers. ","version":null,"tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/QuickZone/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#overview","content":" QuickZone is a lightweight spatial library for Roblox that replaces expensive physics queries with fast, math-based entity tracking at scale. Instead of the physics engine, it uses geometric math while providing a predictable, budgeted, and flexible solution for zone detection, making it possible to track thousands of entities across hundreds of zones with very little impact on your frame rate.  Point-Based Detection QuickZone uses point-based detection. It checks if a specific point (e.g., the center of a Part, the position of an Attachment, or the Pivot of a Model) is inside a zone's boundary. Because it calculates if it is inside or not using geometric math instead of physics-based volume intersections, it is significantly faster than other zone detection libraries.  ","version":"Next","tagName":"h2"},{"title":"Core Features​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#core-features","content":" Fast Spatial Queries: Process thousands of spatial queries per second with negligible FPS impact. Track Anything: Track BaseParts, Models, Attachments, Bones, Cameras, or even pure Lua tables. If it has a position, QuickZone can track it. Shape Support: Supports mathematical containment for Blocks, Balls, Cylinders, and Wedges without relying on physics collision meshes. Decoupled Architecture: Separate game logic from spatial instances. Bind behaviors to categories of entities (Players, NPCs, Projectiles) for a clean, scalable architecture. Budgeted Scheduler: Remove lag spikes by setting a hard frame budget (e.g., 1ms). Workload is smeared across frames to maintain a flat and predictable performance profile. Zero-Allocation Runtime: By using contiguous arrays and object pooling, QuickZone reduces GC pressure, avoiding memory-related stutters.  ","version":"Next","tagName":"h2"},{"title":"Benchmarks​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#benchmarks","content":" The following benchmarks were recorded over 30 seconds with 2,000 moving entities and 100 zones.  Metric\tQuickZone\tZonePlus\tSimpleZone\tQuickBounds\tEmpty ScriptFPS\t42.37\t29.88\t37.23\t41.31\t42.73 Events/s\t2271\t2482\t2518\t566\t0 Memory Usage (MB)\t2.13\t159\t1.77\t2.60\t1.04  ","version":"Next","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#installation","content":" ","version":"Next","tagName":"h2"},{"title":"Wally​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#wally","content":" The package name + version is  ldgerrits/quickzone@^0.2.3   ","version":"Next","tagName":"h3"},{"title":"Manual​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#manual","content":" Download the latest .rbxm model file from the Releases tab and drag it into ReplicatedStorage.  ","version":"Next","tagName":"h3"},{"title":"Quick Start​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#quick-start","content":" The following example demonstrates a 'Water Zone' system. It uses an Observer to apply swimming logic to the LocalPlayerGroup only when they are inside a specific area.  local Players = game:GetService('Players') local ReplicatedStorage = game:GetService('ReplicatedStorage') local QuickZone = require(ReplicatedStorage.QuickZone) -- Create a LocalPlayerGroup that automatically tracks the client's character (including respawns) local myPlayer = QuickZone.LocalPlayerGroup() -- Create an observer with a priority of 42. If zones overlap, higher priority observers resolve first. local swimObserver = QuickZone.Observer(42) swimObserver:subscribe(myPlayer) -- Define behavior swimObserver:onLocalPlayerEntered(function(zone) local char = Players.LocalPlayer.Character if char then char.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, true) char.Humanoid:ChangeState(Enum.HumanoidStateType.Swimming) end end) swimObserver:onLocalPlayerExited(function(zone) local char = Players.LocalPlayer.Character if char then char.Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp) end end) -- Create zones and attach them to the observer to let the observer 'see' local poolZone = QuickZone.ZoneFromPart(workspace.PoolWater) poolZone:attach(swimObserver)  ","version":"Next","tagName":"h2"},{"title":"Observer","type":0,"sectionRef":"#","url":"/QuickZone/api/Observer","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#functions","content":" ","version":null,"tagName":"h2"},{"title":"subscribe​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#subscribe","content":"&lt;/&gt; Observer:subscribe( ...: Group-- The groups to monitor. ) → Observer Links this observer to one or more entity groups. The observer will only track entities that belong to subscribed groups. observer:subscribe(QuickZone.PlayerGroup())   ","version":null,"tagName":"h3"},{"title":"unsubscribe​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#unsubscribe","content":"&lt;/&gt; Observer:unsubscribe( ...: Group-- The groups to stop monitoring. ) → Observer Stops the observer from monitoring the specified groups.  ","version":null,"tagName":"h3"},{"title":"onEntered​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onEntered","content":"Event &lt;/&gt; Observer:onEntered(callback: ( entity: Entity, zone: Zone, metadata: any? ) → ()) → () → ()-- A function that, when called, disconnects the callback. Fires when any entity from a subscribed group enters a zone attached to this observer. local disconnect = observer:onEntered(function(entity, zone, metadata) print(entity.Name .. ' entered ' .. zone.id) end)   ","version":null,"tagName":"h3"},{"title":"onExited​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onExited","content":"Event &lt;/&gt; Observer:onExited(callback: ( entity: Entity, zone: Zone, metadata: any? ) → ()) → () → ()-- A function that, when called, disconnects the callback. Fires when an entity exits all zones attached to this observer.  ","version":null,"tagName":"h3"},{"title":"onPlayerEntered​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onPlayerEntered","content":"Event &lt;/&gt; Observer:onPlayerEntered(callback: ( player: Player , zone: Zone ) → ()) → () → () Specialized event for Player entities.  ","version":null,"tagName":"h3"},{"title":"onPlayerExited​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onPlayerExited","content":"Event &lt;/&gt; Observer:onPlayerExited(callback: ( player: Player , zone: Zone ) → ()) → () → ()-- A function to disconnect the callback. A specialized event for Player entities. Fires when a player's character exits all zones attached to this observer.  ","version":null,"tagName":"h3"},{"title":"onLocalPlayerEntered​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onLocalPlayerEntered","content":"This item only works when running on the client. Client Event &lt;/&gt; Observer:onLocalPlayerEntered(callback: (zone: Zone) → ()) → () → () Specialized event for the LocalPlayer.  ","version":null,"tagName":"h3"},{"title":"onLocalPlayerExited​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onLocalPlayerExited","content":"This item only works when running on the client. Client Event &lt;/&gt; Observer:onLocalPlayerExited(callback: (zone: Zone) → ()) → () → () A specialized event for the LocalPlayer. Fires when the local player's character exits all zones attached to this observer.  ","version":null,"tagName":"h3"},{"title":"setEnabled​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#setEnabled","content":"&lt;/&gt; Observer:setEnabled(enabled: boolean) → Observer Enables or disables the observer. When disabled, it will no longer process spatial checks or fire events.  ","version":null,"tagName":"h3"},{"title":"setPriority​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#setPriority","content":"&lt;/&gt; Observer:setPriority(p: number) → Observer Updates the resolution priority of the observer.  ","version":null,"tagName":"h3"},{"title":"isEnabled​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isEnabled","content":"&lt;/&gt; Observer:isEnabled() → boolean Checks if the observer is currently enabled.  ","version":null,"tagName":"h3"},{"title":"isPlayerInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isPlayerInside","content":"&lt;/&gt; Observer:isPlayerInside(player: Player ) → boolean Checks if a specific player's character is currently inside a zone attached to this observer.  ","version":null,"tagName":"h3"},{"title":"isLocalPlayerInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isLocalPlayerInside","content":"This item only works when running on the client. Client &lt;/&gt; Observer:isLocalPlayerInside() → boolean Checks if the local player's character is currently inside a zone attached to this observer.  ","version":null,"tagName":"h3"},{"title":"isEntityInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isEntityInside","content":"&lt;/&gt; Observer:isEntityInside(entity: Entity) → boolean Checks if a specific entity is currently inside a zone attached to this observer.  ","version":null,"tagName":"h3"},{"title":"isPointInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isPointInside","content":"&lt;/&gt; Observer:isPointInside(position: Vector3 ) → boolean Checks if a specific point in world space is inside any zone attached to this observer.  ","version":null,"tagName":"h3"},{"title":"getId​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getId","content":"&lt;/&gt; Observer:getId() → number Returns the unique internal ID of the observer.  ","version":null,"tagName":"h3"},{"title":"getPriority​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getPriority","content":"&lt;/&gt; Observer:getPriority() → number Returns the current resolution priority.  ","version":null,"tagName":"h3"},{"title":"getEntitiesInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getEntitiesInside","content":"&lt;/&gt; Observer:getEntitiesInside() → {Entity} Returns a list of all tracked entities currently inside zones attached to this observer.  ","version":null,"tagName":"h3"},{"title":"getZones​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getZones","content":"&lt;/&gt; Observer:getZones() → {Zone} Returns the list of Zones currently attached to this observer.  ","version":null,"tagName":"h3"},{"title":"getGroups​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getGroups","content":"&lt;/&gt; Observer:getGroups() → {Group} Returns the list of Groups currently monitored by this observer.  ","version":null,"tagName":"h3"},{"title":"destroy​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#destroy","content":"Destructor &lt;/&gt; Observer:destroy() → () Cleans up the observer, disables tracking, and unsubscribes it from all groups and zones. ","version":null,"tagName":"h3"},{"title":"QuickZone","type":0,"sectionRef":"#","url":"/QuickZone/api/QuickZone","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#types","content":" ","version":null,"tagName":"h2"},{"title":"ShapeType​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#ShapeType","content":"&lt;/&gt; type ShapeType = &quot;Block&quot; | &quot;Ball&quot; | &quot;Cylinder&quot; | &quot;Wedge&quot; | &quot;CornerWedge&quot; The geometric shape of a Zone.  ","version":null,"tagName":"h3"},{"title":"ZoneConfig​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#ZoneConfig","content":"&lt;/&gt; interface ZoneConfig { cframe: CFrame -- The center position and orientation. size: Vector3 -- The full dimensions of the zone. shape: ShapeType-- The geometric shape ('Block', 'Ball', 'Cylinder', etc). part: BasePart? -- Optional part to sync the zone with. isDynamic: boolean?-- Optionally set to true if the zone moves/resizes (i.e. not static). metadata: any?-- Optional metadata. }   ","version":null,"tagName":"h3"},{"title":"Entity​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#Entity","content":"&lt;/&gt; type Entity = BasePart | Model | Camera | Attachment | Bone | EntityTable An Entity is any object that can be tracked within a Group. It supports native Roblox Instances and custom duck-typed tables.  ","version":null,"tagName":"h3"},{"title":"EntityTable​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#EntityTable","content":"&lt;/&gt; interface EntityTable { Position: Vector3? WorldPosition: Vector3? CFrame: CFrame? GetPivot: (() → CFrame )? } A custom table that mimics the spatial properties of a Roblox Instance. QuickZone will automatically detect which property to use to track this entity. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#functions","content":" ","version":null,"tagName":"h2"},{"title":"Zone​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#Zone","content":"Constructor &lt;/&gt; QuickZone.Zone(config: ZoneConfig) → Zone Creates a Zone object. local zone = QuickZone.Zone({ cframe = CFrame.new(0, 10, 0), size = Vector3.new(10, 10, 10), shape = 'Block', metadata = { Name = &quot;Lobby&quot; } }) Performance If this zone moves (e.g., attached to a moving platform) or changes size, you must set isDynamic to true. Static zones are optimized into a large, pre-calculated tree. Updating a static zone forces a full recalculation of that tree, which is expensive. Dynamic zones are handled separately and are much cheaper to update.  ","version":null,"tagName":"h3"},{"title":"ZoneFromPart​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#ZoneFromPart","content":"Constructor &lt;/&gt; QuickZone.ZoneFromPart( part: BasePart ,-- The part to derive the zone from. isDynamic: boolean?,-- Whether the zone should follow the part every frame. metadata: any? ) → Zone Creates a Zone automatically based on a Part's properties. Supported shapes: Block, Ball (Spheres), Cylinder, and Wedge.  ","version":null,"tagName":"h3"},{"title":"Observer​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#Observer","content":"Constructor &lt;/&gt; QuickZone.Observer( priority: number?-- The priority level (defaults to 0). ) → Observer Creates an Observer. Observers listen for entities entering or exiting assigned Zones. Resolution Priority The priority value is used to resolve overlaps. When an entity is inside multiple zones watched by different observers, higher priority observers take precedence in specific logic chains.  ","version":null,"tagName":"h3"},{"title":"Group​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#Group","content":"Constructor &lt;/&gt; QuickZone.Group(config: { updateRate: number?, precision: number?, safety: boolean? }?) → Group Creates a generic Group. Groups manage collections of Entities (any instance with a position in the world like BaseParts, Models, Attachments, etc.) that Observers should track. local myGroup = QuickZone.Group({ updateRate = 20, -- Check at 20Hz precision = 0.5, -- Ignore movement smaller than 0.5 studs safety = true -- Wrap callbacks in task.spawn })   ","version":null,"tagName":"h3"},{"title":"PlayerGroup​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#PlayerGroup","content":"Constructor &lt;/&gt; QuickZone.PlayerGroup(config: { updateRate: number?, precision: number?, safety: boolean? }?) → Group Returns a singleton Group that automatically tracks all Players in the server. Behavior Automatically tracks the HumanoidRootPart of every player. Handles PlayerAdded and CharacterAdded internally. If a LocalPlayerGroup exists on the client, the local player is excluded from this group to avoid duplicate tracking.   ","version":null,"tagName":"h3"},{"title":"LocalPlayerGroup​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#LocalPlayerGroup","content":"This item only works when running on the client. Client Constructor &lt;/&gt; QuickZone.LocalPlayerGroup(config: { updateRate: number?, precision: number?, safety: boolean? }?) → Group Returns a singleton Group that tracks only the LocalPlayer. Behavior This group takes 'ownership of the local player's character. When this group is destroyed, the local player is automatically handed back to the global PlayerGroup if it exists.   ","version":null,"tagName":"h3"},{"title":"setFrameBudget​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#setFrameBudget","content":"&lt;/&gt; QuickZone:setFrameBudget( ms: number-- Time in milliseconds ) → QuickZone Sets the global execution budget for the Scheduler per frame in milliseconds. The Scheduler will 'dispatch' entity updates until this threshold is reached, at which point it yields until the next frame to prevent render stutter. Defaults to 1ms. -- Allow QuickZone to use up to 0.5ms of frame time QuickZone:setFrameBudget(0.5)   ","version":null,"tagName":"h3"},{"title":"getZonesAtPoint​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getZonesAtPoint","content":"&lt;/&gt; QuickZone:getZonesAtPoint( position: Vector3 -- The world position to check. ) → {Zone} Performs a spatial query to find all Zones containing the given point.  ","version":null,"tagName":"h3"},{"title":"getObserversAtPoint​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getObserversAtPoint","content":"&lt;/&gt; QuickZone:getObserversAtPoint( position: Vector3 -- The world position to check. ) → {Observer} Finds all Observers whose assigned Zones contain the given point.  ","version":null,"tagName":"h3"},{"title":"getGroupOfEntity​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getGroupOfEntity","content":"&lt;/&gt; QuickZone:getGroupOfEntity( entity: Entity-- The Part, Model, or Table entity. ) → Group? Returns the Group that the specified entity currently belongs to.  ","version":null,"tagName":"h3"},{"title":"getZones​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getZones","content":"&lt;/&gt; QuickZone:getZones() → {Zone} Returns an array containing every Zone currently registered in the system. This includes both static and dynamic zones.  ","version":null,"tagName":"h3"},{"title":"getObservers​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getObservers","content":"&lt;/&gt; QuickZone:getObservers() → {Observer} Returns an array of all Observers currently existing in the system.  ","version":null,"tagName":"h3"},{"title":"getGroups​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getGroups","content":"&lt;/&gt; QuickZone:getGroups() → {Group} Returns an array of all Groups (including PlayerGroups) currently registered in the system.  ","version":null,"tagName":"h3"},{"title":"getEntities​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getEntities","content":"&lt;/&gt; QuickZone:getEntities() → {Entity} Returns a flattened array of every Entity (Parts, Models, etc.) currently being tracked across all Groups.  ","version":null,"tagName":"h3"},{"title":"visualize​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#visualize","content":"Debug &lt;/&gt; QuickZone:visualize( enabled: boolean-- Whether to show the debug visuals. ) → QuickZone Enables or disables visual rendering of all registered Zones. Static and Dynamic zones are colored differently based on their active status. ","version":null,"tagName":"h3"},{"title":"Zone","type":0,"sectionRef":"#","url":"/QuickZone/api/Zone","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#functions","content":" ","version":null,"tagName":"h2"},{"title":"attach​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#attach","content":"&lt;/&gt; Zone:attach( ...: Observer-- The observers to link. ) → Zone Attaches one or more Observers to this zone. The observers will begin monitoring this area for entity overlaps. zone:attach(myObserver)   ","version":null,"tagName":"h3"},{"title":"detach​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#detach","content":"&lt;/&gt; Zone:detach( ...: Observer-- The observers to unlink. ) → Zone Detaches observers from this zone.  ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#update","content":"&lt;/&gt; Zone:update( newCFrame: CFrame? ,-- Optional new position/rotation. newSize: Vector3? -- Optional new dimensions. ) → Zone Updates the zone's position and size. -- Manual update zone:update(CFrame.new(0, 20, 0), Vector3.new(5, 5, 5)) -- Sync with associated part zone:update() Auto-Sync If the zone was created with an associatedPart, calling update() without arguments will automatically sync the zone to that part's current CFrame and Size.  ","version":null,"tagName":"h3"},{"title":"setMetadata​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#setMetadata","content":"&lt;/&gt; Zone:setMetadata() → number Set the metadata of the zone.  ","version":null,"tagName":"h3"},{"title":"getMetadata​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getMetadata","content":"&lt;/&gt; Zone:getMetadata() → number Returns the metadata of the zone.  ","version":null,"tagName":"h3"},{"title":"getId​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getId","content":"&lt;/&gt; Zone:getId() → number Returns the unique internal ID of the zone.  ","version":null,"tagName":"h3"},{"title":"getPart​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getPart","content":"&lt;/&gt; Zone:getPart() → BasePart?  Returns the BasePart associated with this zone, if any.  ","version":null,"tagName":"h3"},{"title":"getShapeType​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getShapeType","content":"&lt;/&gt; Zone:getShapeType() → ShapeType Returns the geometric shape type of the zone.  ","version":null,"tagName":"h3"},{"title":"getObservers​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getObservers","content":"&lt;/&gt; Zone:getObservers() → {Observer} Returns a list of all Observers currently attached to this zone.  ","version":null,"tagName":"h3"},{"title":"isPointInside​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#isPointInside","content":"&lt;/&gt; Zone:isPointInside(point: Vector3 ) → boolean Checks if a point is inside this specific zone.  ","version":null,"tagName":"h3"},{"title":"isDynamic​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#isDynamic","content":"&lt;/&gt; Zone:isDynamic() → boolean Returns whether the zone is currently registered as a dynamic object.  ","version":null,"tagName":"h3"},{"title":"destroy​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#destroy","content":"Destructor &lt;/&gt; Zone:destroy() → () Cleans up the zone, removes it from the LBVH tree, and detaches all observers. ","version":null,"tagName":"h3"},{"title":"Usage","type":0,"sectionRef":"#","url":"/QuickZone/docs/usage","content":"","keywords":"","version":"Next"},{"title":"Zones​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#zones","content":" Zones represent physical areas in the world. They are mathematical boundaries that can be static (fixed in space) or dynamic (following a part). They can be created from existing parts or defined manually with a CFrame and Size.  ","version":"Next","tagName":"h2"},{"title":"Creation​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#creation","content":" The easiest way to create a zone.  -- Static Zone (Fastest) -- Ideal for shops, biomes, or permanent regions. local staticZone = QuickZone.ZoneFromPart(workspace.SafeZone) -- Dynamic Zone -- Passing 'true' makes the zone follow the part's CFrame on :update() local trainZone = QuickZone.ZoneFromPart(workspace.TrainCarriage, true, { canDamage = true })   Note: The third argument (metadata) is optional and can be retrieved using zone:getMetadata()  ","version":"Next","tagName":"h3"},{"title":"Manual Creation​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#manual-creation","content":" Useful for procedural generation or areas without physical parts.  local zone = QuickZone.Zone({ cframe = CFrame.new(0, 10, 0), size = Vector3.new(10, 10, 10), shape = 'Block', isDynamic = true, metadata = { Name = 'Lobby' } })   Performance Optimization: Static vs. Dynamic QuickZone batches tree rebuilds once per frame. By keeping the Dynamic Tree small, you make sure that these batched rebuilds remain super quick. For maximum perfomance, use isDynamic = true for zones attached to moving platforms, vehicles, or projectiles.  ","version":"Next","tagName":"h3"},{"title":"Updating Zones​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#updating-zones","content":" If you create a zone manually or want to sync a dynamic zone to a new reference, use :update().  -- Manually move a zone zone:update(CFrame.new(0, 50, 0), Vector3.new(10, 10, 10)) -- Sync a dynamic zone to its associated part dynamicZone:update()   ","version":"Next","tagName":"h3"},{"title":"Groups​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#groups","content":" Groups are collections of entities (Parts, Models, Players, etc.). They allow you to categorize entities and set unique performance settings per category.  ","version":"Next","tagName":"h2"},{"title":"Specialized Groups​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#specialized-groups","content":" QuickZone provides built-in abstractions that automatically handle player lifecyles.  -- Tracks all players in the server local allPlayers = QuickZone.PlayerGroup() -- Tracks only the local player (client-side only) local myPlayer = QuickZone.LocalPlayerGroup()   ","version":"Next","tagName":"h3"},{"title":"Custom Groups​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#custom-groups","content":" For NPCs, projectiles, or vehicles, create a standard Group.  local projectiles = QuickZone.Group({ updateRate = 60, -- Check every frame for high-speed objects precision = 0, -- Query every time it moves safety = false -- Fire callbacks immediately (faster but risky if you yield) }) local NPCs = QuickZone.Group({ updateRate = 5, -- Check only 5 times a second precision = 2.0 -- Only query if the NPC moves more than 2 studs })   ","version":"Next","tagName":"h3"},{"title":"Managing Entities​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#managing-entities","content":" You can add BaseParts, Models, Attachments, Bones, or tables with a Position.  -- Add a Model (tracks the PrimaryPart or Pivot) enemies:add(npcModel, { Team = 'Red' }) -- Add a specific Attachment (tracks the exact point) -- This is great for offsets if you do not want to track the middle of a part (e.g. sword tip) enemies:add(sword.TipAttachment, { Damage = 75 }) -- Add a table local spell = { Position = Vector3.new(10, 5, 0) } enemies:add(spell) -- Remove when done enemies:remove(npcModel)   Note: The second argument (metadata) is optional and will be passed to your event callbacks.  ","version":"Next","tagName":"h3"},{"title":"Observers​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#observers","content":" Observers act as the logic layer. They subscribe to Groups and attach to Zones to bridge spatial data with game behavior.  ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#setup","content":" An Observer listens to its subscribed Groups and checks if they overlap with its attached Zones.  local observer = QuickZone.Observer() observer:subscribe(allPlayers) -- Who to watch healingZone:attach(observer) -- Where to watch   ","version":"Next","tagName":"h3"},{"title":"Events​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#events","content":" Events are defined on the Observer, not the Zone or Group. Events return a cleanup function.  -- Fires when an entity enters a zone for this observer local enteredConn = observer:onEntered(function(entity, zone, metadata) print(entity.Name .. ' entered ' .. zone:getId() ... ' with ' ... tostring(zone:getMetadata())) end) -- Fires when an entity enters a zone for this observer local exitedConn = observer:onExited(function(entity, zone, metadata) print(entity.Name .. ' exited ' .. zone:getId() ... ' with ' ... tostring(zone:getMetadata())) end) -- Convenience Player wrappers observer:onPlayerEntered(function(player, zone) ... end) observer:onPlayerExited(function(player, zone) ... end) observer:onLocalPlayerEntered(function(zone) ... end) observer:onLocalPlayerExited(function(zone) ... end)   ","version":"Next","tagName":"h3"},{"title":"Priority and Resolution​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#priority-and-resolution","content":" Observers use a priority system to handle overlapping zones. An entity 'belongs' to only one zone state per observer at a time when using priorities.  local lowPriority = QuickZone.Observer(0) local highPriority = QuickZone.Observer(10) -- If a player is inside Zone A (Low) and Zone B (High) simultaneously: -- 1. highPriority:onEntered() fires for Zone B. -- 2. lowPriority:onExited() fires for Zone A.   ","version":"Next","tagName":"h3"},{"title":"Observer State​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#observer-state","content":" Observers can be toggled to pause logic without destroying the configuration.  observer:setEnabled(false) -- Fires 'onExited' for everyone inside task.wait(5) observer:setEnabled(true) -- Fires 'onEntered' if they are still there   ","version":"Next","tagName":"h3"},{"title":"Utility​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#utility","content":" ","version":"Next","tagName":"h2"},{"title":"Frame Budget​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#frame-budget","content":" To maintain a high framerate in complex scenes, you can constrain the total CPU time QuickZone is allowed to consume per frame.  -- Allow 0.5 milliseconds per frame (default is 1ms) QuickZone:setFrameBudget(0.5)   ","version":"Next","tagName":"h3"},{"title":"Immediate Spatial Queries​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#immediate-spatial-queries","content":" Perform instant checks without using the Observer/Group pattern.  -- Get all zones at a specific vector local zones = QuickZone:getZonesAtPoint(Vector3.new(10, 5, 0)) -- Get the group an entity belongs to local group = QuickZone:getGroupOfEntity(workspace.Part)   ","version":"Next","tagName":"h3"},{"title":"Debugging​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#debugging","content":" Renders zones in the workspace to verify the setup.  QuickZone:visualize(true)   ","version":"Next","tagName":"h3"},{"title":"Considerations​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#considerations","content":" Point-Based Tracking: QuickZone tracks the precise coordinate of an entity (Center, Attachment, or Pivot). It does not calculate the full volume intersection of the entity itself. Movement Threshold (Precision): QuickZone only re-calculates spatial state when an entity moves beyond a certain distance. Setting a higher precision value (e.g., 2.0 studs) significantly reduces overhead for slow-moving objects. Budgeted Latency: To prevent frame drops, QuickZone 'smears' workload across multiple frames. In high-load scenarios (e.g., thousands of active entities), there may be a slight delay between an entity physically entering a zone and the event firing. ","version":"Next","tagName":"h2"},{"title":"Why use QuickZone?","type":0,"sectionRef":"#","url":"/QuickZone/docs/why-use-quickzone","content":"","keywords":"","version":"Next"},{"title":"The QuickZone Approach​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#the-quickzone-approach","content":" QuickZone bypasses the physics engine in favor of geometric math and data-oriented design. It implements a Linear BVH (LBVH) that resolves spatial queries using math compiled to machine code to prevent interpreter overhead.  ","version":"Next","tagName":"h2"},{"title":"1. The Entity-Centric Model​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#1-the-entity-centric-model","content":" Traditional libraries are Zone-Centric. They iterate through every Zone instance and query the physics engine for overlapping parts (i.e. entities in QuickZone-terms).  The Scaling Problem: Performance worsens as you add more zones (O(Z)), even if the number of entities remains static.  QuickZone, on the other hand, is Entity-Centric. It keeps a list of entities and queries them against an LBVH (O(N log Z)).  The Benefit: This means that you can have hundreds, even thousands, of zones with very low runtime cost. The cost effectively becomes a factor of the number of entities that are being processed.  ","version":"Next","tagName":"h3"},{"title":"2. Data-Oriented Design (DOD)​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#2-data-oriented-design-dod","content":" QuickZone focuses on how data is laid out in memory based on DOD principles.  Contiguous Arrays: Unlike standard OOP where data is scattered across the heap in different objects, QuickZone stores entity data in pre-allocated, contiguous arrays to improve CPU cache locality. Stable Memory: By using flat arrays and object pooling, QuickZone generates almost no garbage during runtime. This prevents lag spikes caused by the GC.  ","version":"Next","tagName":"h3"},{"title":"3. Architecture​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#3-architecture","content":" QuickZone moves away from monolithic, instance-bound logic in favor of a Group-Observer-Zone topology. This architecture separates what is being tracked from where the tracking occurs and how the system should respond.    Groups​  A Group is a collection of entities that share performance characteristics and logical categorization. Performance can be configured per Group.  -- Real-time frequency (60Hz), zero tolerance. local cameraGroup = QuickZone.Group({ updateRate = 60, precision = 0, }) -- Low frequency (2Hz), low precision. local NPCGroup = QuickZone.Group({ updateRate = 2, precision = 4, })   This prevents wasting CPU cycles checking a slow-moving NPC, for example.  Observers​  Observers act as the logic bridge. They subscribe to Groups and attach to Zones, creating a many-to-many relationship that keeps game logic decoupled and clean.  -- Create an Observer and subscribe to a group local safeObserver = QuickZone.Observer() safeObserver:subscribe(QuickZone.LocalPlayerGroup()) -- Logic is defined once, not per zone safeObserver:onEntered(function(player, zone) print('Entered Safe Zone:', zone:getId()) end) -- Create Zones from parts and attach them to the observer for _, part in workspace.SafeZones:GetChildren() do if part:IsA('BasePart') then local zone = QuickZone.ZoneFromPart(part) zone:attach(safeObserver) end end   ","version":"Next","tagName":"h3"},{"title":"4. The Budgeted Scheduler​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#4-the-budgeted-scheduler","content":" A common issue with spatial libraries is stutter due to it processing too many things in one frame. QuickZone fixes this via its smart Scheduler.  Frame Budgeting​  You can set a hard time limit (e.g., 1ms). The Scheduler monitors os.clock() in real-time. If the budget is met, the system pauses immediately and resumes in the next frame. This guarantees that QuickZone will never be the cause of a frame drop.  Workload Smearing​  The scheduler smears updates across frames. This means that, if you have a Group of 600 entities updating at 10Hz, QuickZone will process exactly 100 entities per frame at 60 fps. This ensures that we have flat, predictable performance profile with no peaks or valleys.  No starvation​  The Scheduler uses a Round-Robin strategy for Group processing. Instead of processing groups in order, QuickZone cycles through them fairly. This prevents the issue where a heavy group keeps consuming the entire frame budget and 'starving' the subsequent groups.  ","version":"Next","tagName":"h3"},{"title":"5. Dual-LBVH and Batched Rebuilding​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#5-dual-lbvh-and-batched-rebuilding","content":" To maintain high performance, QuickZone maintains two LBVHs:  The Static LBVH: Contains all non-moving, non-resizing zones. The Dynamic LBVH: Contains zones attached to moving parts (e.g., vehicles, platforms).  Optimization via Batching​  Rebuilding an LBVH is computationally expensive. QuickZone optimizes this by batching updates per frame: if multiple zones are added, removed, or moved in a single frame, QuickZone will only perform a single rebuild at the start of the Scheduler step.  By separating static and dynamic zones, QuickZone minimizes the workload of the LBVH rebuilder. Rebuilding a small tree of 5 moving platforms is significantly faster than rebuilding a tree containing 500 static buildings.  Frame budget Rebuilding the LBVHs is part of the frame budget. Thus, rebuilding will result in less time for processing the groups of entities.  ","version":"Next","tagName":"h3"},{"title":"6. Flexibility​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#6-flexibility","content":" Because QuickZone relies on pure math rather than the Physics engine, it is not limited to BaseParts. It also supports duck typing for entities.  BaseParts: Uses .Position. Models: Uses .PrimaryPart.Position or :GetPivot() (if .PrimaryPart does not exist). Attachments/Bones: Uses .WorldPosition. Cameras: Uses .CFrame.Position. Tables: Uses any custom .Position, .WorldPosition and .CFrame field, or :GetPivot().  This allows you to track real-time simulations (e.g. a spell cast or an RC car) without the overhead of creating physical Instances.  ","version":"Next","tagName":"h3"},{"title":"7. Performance Benchmarks​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#7-performance-benchmarks","content":" In a stress test with 2,000 moving entities and 100 zones recorded over 30 seconds, QuickZone leads the pack:  Metric\tQuickZone\tZonePlus\tSimpleZone\tQuickBounds\tEmpty ScriptFPS\t42.37\t29.88\t37.23\t41.31\t42.73 Events/s\t2271\t2482\t2518\t566\t0 Memory Usage (MB)\t2.13\t159\t1.77\t2.60\t1.04  Note: For the QuickZone benchmark, we used a frame budget of 1ms, the entities' update rate was set to 60Hz, and the precision was 0.0.  FPS Impact: The benchmarks show that QuickZone's had very little negative impact on FPS (-1%) compared to the empty script baseline. In comparison, ZonePlus drops the game from ~43 to ~30 FPS (-28%) under the same load, while SimpleZone drops to ~37 FPS (-13%). Memory Footprint: QuickZone's memory footprint is ~98% smaller than ZonePlus and on par with SimpleZone and QuickBounds, while keeping GC pressure low. Event Throughput: QuickZone handles a similar number of events compared to ZonePlus and SimpleZone. QuickZone's slight 10% decrease can be attributed to ZonePlus and SimpleZone being volume-based instead of point-based. Moreover, QuickZone handles 4x the event volume (2271 events/s) compared to QuickBounds (566 events/s). ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}