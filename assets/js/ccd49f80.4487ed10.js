"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[304],{7580:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"why-use-quickzone","title":"Why use QuickZone?","description":"Traditional zone libraries like ZonePlus and SimpleZone act as wrappers for Roblox\'s physics engine (e.g., GetBoundsInBox, GetPartsInPart or .Touched), resulting in expensive collision geometry calculations and synchronization overhead.","source":"@site/docs/why-use-quickzone.md","sourceDirName":".","slug":"/why-use-quickzone","permalink":"/QuickZone/docs/why-use-quickzone","draft":false,"unlisted":false,"editUrl":"https://github.com/LDgerrits/QuickZone/edit/main/docs/why-use-quickzone.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"defaultSidebar","previous":{"title":"Usage","permalink":"/QuickZone/docs/usage"}}');var t=i(4848),r=i(8453);const o={sidebar_position:3},d="Why use QuickZone?",a={},l=[{value:"1. The Entity-Centric Model",id:"1-the-entity-centric-model",level:3},{value:"2. Data-Oriented Design (DOD)",id:"2-data-oriented-design-dod",level:3},{value:"3. Architecture",id:"3-architecture",level:3},{value:"Groups",id:"groups",level:4},{value:"Observers",id:"observers",level:4},{value:"4. The Budgeted Scheduler",id:"4-the-budgeted-scheduler",level:3},{value:"Frame Budgeting",id:"frame-budgeting",level:4},{value:"Workload Smearing",id:"workload-smearing",level:4},{value:"No starvation",id:"no-starvation",level:4},{value:"5. Dual-LBVH and Batched Rebuilding",id:"5-dual-lbvh-and-batched-rebuilding",level:3},{value:"Optimization via Batching",id:"optimization-via-batching",level:4},{value:"6. Flexibility",id:"6-flexibility",level:3},{value:"7. Performance Benchmarks",id:"7-performance-benchmarks",level:3},{value:"Test 1: High Zone Count",id:"test-1-high-zone-count",level:3},{value:"Test 2: High Entity Count",id:"test-2-high-entity-count",level:3}];function c(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"why-use-quickzone",children:"Why use QuickZone?"})}),"\n",(0,t.jsxs)(n.p,{children:["Traditional zone libraries like ZonePlus and SimpleZone act as wrappers for Roblox's physics engine (e.g., ",(0,t.jsx)(n.code,{children:"GetBoundsInBox"}),", ",(0,t.jsx)(n.code,{children:"GetPartsInPart"})," or ",(0,t.jsx)(n.code,{children:".Touched"}),"), resulting in expensive collision geometry calculations and synchronization overhead."]}),"\n",(0,t.jsx)(n.p,{children:"QuickZone bypasses the physics engine in favor of geometric math and data-oriented design. It implements a Linear BVH (LBVH) that resolves spatial queries using math compiled to machine code to prevent interpreter overhead."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"1-the-entity-centric-model",children:"1. The Entity-Centric Model"}),"\n",(0,t.jsx)(n.p,{children:"Traditional libraries are Zone-Centric. They iterate through every Zone instance and query the physics engine for overlapping parts (i.e. entities in QuickZone-terms)."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"The Scaling Problem"}),": Performance worsens as you add more zones (",(0,t.jsx)(n.em,{children:"O(Z)"}),"), even if the number of entities remains static."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["QuickZone, on the other hand, is Entity-Centric. It keeps a list of entities and queries them against an LBVH (",(0,t.jsx)(n.em,{children:"O(N log Z)"}),")."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"The Benefit"}),": This means that you can have hundreds, even thousands, of zones with very low runtime cost. The cost effectively becomes a factor of the number of entities that are being processed."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"2-data-oriented-design-dod",children:"2. Data-Oriented Design (DOD)"}),"\n",(0,t.jsx)(n.p,{children:"QuickZone focuses on how data is laid out in memory based on DOD principles."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Contiguous Arrays"}),": Unlike standard OOP where data is scattered across the heap in different objects, QuickZone stores entity data in pre-allocated, contiguous arrays to improve CPU cache locality."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Stable Memory"}),": By using flat arrays and object pooling, QuickZone generates almost no garbage during runtime. This prevents lag spikes caused by the GC."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"3-architecture",children:"3. Architecture"}),"\n",(0,t.jsx)(n.p,{children:"QuickZone moves away from monolithic, instance-bound logic in favor of a Group-Observer-Zone topology. This architecture separates what is being tracked from where the tracking occurs and how the system should respond."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Priority",src:i(8445).A+"",width:"740",height:"460"})}),"\n",(0,t.jsx)(n.h4,{id:"groups",children:"Groups"}),"\n",(0,t.jsx)(n.p,{children:"A Group is a collection of entities that share performance characteristics and logical categorization. Performance can be configured per Group, like setting the update rate in Hz or the precision, i.e. the minimum distance threshold to perform a spatial query, in studs. This prevents wasting CPU cycles checking a slow-moving NPC, for example."}),"\n",(0,t.jsx)(n.h4,{id:"observers",children:"Observers"}),"\n",(0,t.jsx)(n.p,{children:"Observers act as the logic bridge. They subscribe to Groups and are attach by Zones, creating a many-to-many relationship that keeps game logic decoupled and clean."}),"\n",(0,t.jsxs)(n.p,{children:["Because Observers are decoupled from the physics engine, they can aggregate spatial data. Tracking an entire Group costs no additional spatial queries.And using ",(0,t.jsx)(n.code,{children:"observeGroup()"}),", an Observer can fire an event when the first member of a Group enters a zone, and clean up when the last member leaves."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"4-the-budgeted-scheduler",children:"4. The Budgeted Scheduler"}),"\n",(0,t.jsx)(n.p,{children:"A common issue with spatial libraries is stutter due to it processing too many things in one frame. QuickZone fixes this via its smart Scheduler."}),"\n",(0,t.jsx)(n.h4,{id:"frame-budgeting",children:"Frame Budgeting"}),"\n",(0,t.jsx)(n.p,{children:"You can set a hard time limit (e.g., 1ms). The Scheduler monitors os.clock() in real-time. If the budget is met, the system pauses immediately and resumes in the next frame. This guarantees that QuickZone will never be the cause of a frame drop."}),"\n",(0,t.jsx)(n.h4,{id:"workload-smearing",children:"Workload Smearing"}),"\n",(0,t.jsx)(n.p,{children:"The scheduler smears updates across frames. This means that, if you have a Group of 600 entities updating at 10Hz, QuickZone will process exactly 100 entities per frame at 60 fps. This ensures that we have flat, predictable performance profile with no peaks or valleys."}),"\n",(0,t.jsx)(n.h4,{id:"no-starvation",children:"No starvation"}),"\n",(0,t.jsx)(n.p,{children:"The Scheduler uses a Round-Robin strategy for Group processing. Instead of processing groups in order, QuickZone cycles through them fairly. This prevents the issue where a heavy group keeps consuming the entire frame budget and 'starving' the subsequent groups."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"5-dual-lbvh-and-batched-rebuilding",children:"5. Dual-LBVH and Batched Rebuilding"}),"\n",(0,t.jsx)(n.p,{children:"To maintain high performance, QuickZone maintains two LBVHs:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The Static LBVH"}),": Contains all non-moving, non-resizing zones."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The Dynamic LBVH"}),": Contains zones attached to moving parts (e.g., vehicles, platforms)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"optimization-via-batching",children:"Optimization via Batching"}),"\n",(0,t.jsx)(n.p,{children:"Rebuilding an LBVH is computationally expensive. QuickZone optimizes this by batching updates per frame: if multiple zones are added, removed, or moved in a single frame, QuickZone will only perform a single rebuild at the start of the Scheduler step."}),"\n",(0,t.jsx)(n.p,{children:"By separating static and dynamic zones, QuickZone minimizes the workload of the LBVH rebuilder. Rebuilding a small tree of 5 moving platforms is significantly faster than rebuilding a tree containing 500 static buildings."}),"\n",(0,t.jsx)(n.admonition,{title:"Frame budget",type:"info",children:(0,t.jsx)(n.p,{children:"Rebuilding the LBVHs is part of the frame budget. Thus, rebuilding will result in less time for processing the groups of entities."})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"6-flexibility",children:"6. Flexibility"}),"\n",(0,t.jsx)(n.p,{children:"Because QuickZone relies on pure math rather than the Physics engine, it is not limited to BaseParts. It also supports duck typing for entities."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"BaseParts"}),": Uses ",(0,t.jsx)(n.code,{children:".Position"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Models"}),": Uses ",(0,t.jsx)(n.code,{children:".PrimaryPart.Position"})," or ",(0,t.jsx)(n.code,{children:":GetPivot()"})," (if ",(0,t.jsx)(n.code,{children:".PrimaryPart"})," does not exist)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Attachments/Bones"}),": Uses ",(0,t.jsx)(n.code,{children:".WorldPosition"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cameras"}),": Uses ",(0,t.jsx)(n.code,{children:".CFrame.Position"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Tables"}),": Uses any custom ",(0,t.jsx)(n.code,{children:".Position"}),", ",(0,t.jsx)(n.code,{children:".WorldPosition"})," and ",(0,t.jsx)(n.code,{children:".CFrame"})," field, or ",(0,t.jsx)(n.code,{children:":GetPivot()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This allows you to track real-time simulations (e.g. a spell cast or an RC car) without the overhead of creating physical Instances."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"7-performance-benchmarks",children:"7. Performance Benchmarks"}),"\n",(0,t.jsxs)(n.p,{children:["We stress-tested QuickZone against the most popular alternatives in two distinct scenarios: ",(0,t.jsx)(n.strong,{children:"Entity Stress"})," (lots of moving parts) and ",(0,t.jsx)(n.strong,{children:"Map Stress"})," (lots of zones)."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Note: For the QuickZone benchmark, we used a frame budget of 1ms, the entities' update rate was set to 60Hz, and precision was 0.0."})}),"\n",(0,t.jsx)(n.h3,{id:"test-1-high-zone-count",children:"Test 1: High Zone Count"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Scenario: 500 moving entities, 10,000 zones, recorded over 30 seconds."})}),"\n",(0,t.jsx)(n.p,{children:"This test highlights the fundamental flaw in traditional Zone-Centric libraries. As map complexity grows, their performance degrades exponentially."}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Metric"}),(0,t.jsx)(n.th,{children:"QuickZone"}),(0,t.jsx)(n.th,{children:"ZonePlus"}),(0,t.jsx)(n.th,{children:"SimpleZone"}),(0,t.jsx)(n.th,{children:"QuickBounds"}),(0,t.jsx)(n.th,{children:"Empty Script"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"FPS"}),(0,t.jsx)(n.td,{children:"59.25"}),(0,t.jsx)(n.td,{children:"3.84"}),(0,t.jsx)(n.td,{children:"5.53"}),(0,t.jsx)(n.td,{children:"58.95"}),(0,t.jsx)(n.td,{children:"59.28"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Events/s"}),(0,t.jsx)(n.td,{children:"643"}),(0,t.jsx)(n.td,{children:"627"}),(0,t.jsx)(n.td,{children:"519"}),(0,t.jsx)(n.td,{children:"328"}),(0,t.jsx)(n.td,{children:"0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Memory Usage (MB)"}),(0,t.jsx)(n.td,{children:"18.57"}),(0,t.jsx)(n.td,{children:"4230"}),(0,t.jsx)(n.td,{children:"99.79"}),(0,t.jsx)(n.td,{children:"17.62"}),(0,t.jsx)(n.td,{children:"0.65"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The Result:"})," QuickZone maintained a perfect 60 FPS."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"ZonePlus and SimpleZone imploded, dropping to 3-5 FPS, making the game unplayable."}),"\n",(0,t.jsx)(n.li,{children:"ZonePlus consumed over 4 GB of memory, which would crash most mobile devices instantly."}),"\n",(0,t.jsxs)(n.li,{children:["QuickZone proved it is ",(0,t.jsx)(n.em,{children:"O(N)"})," relative to entities, not zones. You can add as many zones as you want without performance penalties."]}),"\n",(0,t.jsx)(n.li,{children:"QuickZone vs. QuickBounds: Both libraries scaled well by maintaining ~60 FPS. However, QuickZone still maintained a slight FPS lead and, more importantly, delivered double the event throughput (643 vs 328) compared to QuickBounds."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"test-2-high-entity-count",children:"Test 2: High Entity Count"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Scenario: 2,000 moving entities, 100 zones, recorded over 30 seconds."})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Metric"}),(0,t.jsx)(n.th,{children:"QuickZone"}),(0,t.jsx)(n.th,{children:"ZonePlus"}),(0,t.jsx)(n.th,{children:"SimpleZone"}),(0,t.jsx)(n.th,{children:"QuickBounds"}),(0,t.jsx)(n.th,{children:"Empty Script"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"FPS"}),(0,t.jsx)(n.td,{children:"42.37"}),(0,t.jsx)(n.td,{children:"29.88"}),(0,t.jsx)(n.td,{children:"37.23"}),(0,t.jsx)(n.td,{children:"41.31"}),(0,t.jsx)(n.td,{children:"42.73"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Events/s"}),(0,t.jsx)(n.td,{children:"2271"}),(0,t.jsx)(n.td,{children:"2482"}),(0,t.jsx)(n.td,{children:"2518"}),(0,t.jsx)(n.td,{children:"566"}),(0,t.jsx)(n.td,{children:"0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Memory Usage (MB)"}),(0,t.jsx)(n.td,{children:"2.13"}),(0,t.jsx)(n.td,{children:"159"}),(0,t.jsx)(n.td,{children:"1.77"}),(0,t.jsx)(n.td,{children:"2.60"}),(0,t.jsx)(n.td,{children:"1.04"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The Result:"})," QuickZone is the only library that maintained near-baseline FPS (-1% impact)."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"ZonePlus caused a 28% drop in framerate, rendering the game choppy."}),"\n",(0,t.jsx)(n.li,{children:"QuickZone handled the load with 98% less memory than ZonePlus."}),"\n",(0,t.jsx)(n.li,{children:"QuickZone vs. QuickBounds: QuickZone squeezes out more performance, averaging ~1 FPS higher than QuickBounds. More importantly, QuickZone processed 4x the volume of events (2,271 vs 566)."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8445:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/topology_quickzone-b84eba3dd758f5c1d6720894752a8021.png"},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>d});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);