"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[976],{7879:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"intro","title":"Introduction","description":"Overview","source":"@site/docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/QuickZone/docs/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/LDgerrits/QuickZone/edit/main/docs/intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"defaultSidebar","next":{"title":"Usage","permalink":"/QuickZone/docs/usage"}}');var i=t(4848),a=t(8453);const s={sidebar_position:1},o="Introduction",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Core Features",id:"core-features",level:2},{value:"Benchmarks",id:"benchmarks",level:2},{value:"Installation",id:"installation",level:2},{value:"Wally",id:"wally",level:3},{value:"Manual",id:"manual",level:3},{value:"Quick Start",id:"quick-start",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"QuickZone is a high-performance, spatial partitioning library for Roblox."}),"\n",(0,i.jsx)(n.p,{children:"QuickZone makes it possible to track thousands of entities across hundreds of zones with almost no impact on your frame rate. It bypasses Roblox's physics engine in favor of geometric math while providing a predictable, budgeted, and flexible solution for zone detection."}),"\n",(0,i.jsxs)(n.admonition,{title:"Point-Based Detection",type:"info",children:[(0,i.jsx)(n.p,{children:"QuickZone uses point-based detection. It checks if a specific point (e.g., the center of a Part, the position of an Attachment, or the Pivot of a Model) is inside a zone's boundary."}),(0,i.jsx)(n.p,{children:"Because it calculates if it is inside or not using geometric math instead of physics-based volume intersections, it is significantly faster than other zone detection libraries."})]}),"\n",(0,i.jsx)(n.h2,{id:"core-features",children:"Core Features"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Best-In-Class Performance"}),": Process thousands of spatial queries per second with negligible FPS impact."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Smart Scheduler"}),": Autmomatically divides workload equally across frames for a flat, predictable performance profile. Set a hard time limit (e.g., 1ms) to ensure that QuickZone never causes frame drops."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Entity-Centric"}),": Costs are based on the number of tracked entities and not the number of zones."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Group-Observer Topology"}),": Decouple your game logic from spatial instances. You are able to bind behaviors to categories of entities instead of individual parts."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Track Anything"}),": Track BaseParts, Models, Attachments, Bones, Cameras, or even Lua tables."]}),"\n",(0,i.jsx)(n.h2,{id:"benchmarks",children:"Benchmarks"}),"\n",(0,i.jsx)(n.p,{children:"In a scenario with 2,000 moving entities and 100 zones recorded over 30-seconds, the obtained benchmarks were as follows:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Metric"}),(0,i.jsx)(n.th,{children:"QuickZone"}),(0,i.jsx)(n.th,{children:"ZonePlus"}),(0,i.jsx)(n.th,{children:"SimpleZone"}),(0,i.jsx)(n.th,{children:"QuickBounds"}),(0,i.jsx)(n.th,{children:"Empty Script"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"FPS"}),(0,i.jsx)(n.td,{children:"42.37"}),(0,i.jsx)(n.td,{children:"37.23"}),(0,i.jsx)(n.td,{children:"29.88"}),(0,i.jsx)(n.td,{children:"41.31"}),(0,i.jsx)(n.td,{children:"42.73"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Events/s"}),(0,i.jsx)(n.td,{children:"2271"}),(0,i.jsx)(n.td,{children:"2482"}),(0,i.jsx)(n.td,{children:"2518"}),(0,i.jsx)(n.td,{children:"566"}),(0,i.jsx)(n.td,{children:"0"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Memory Usage (MB)"}),(0,i.jsx)(n.td,{children:"2.13"}),(0,i.jsx)(n.td,{children:"159"}),(0,i.jsx)(n.td,{children:"1.77"}),(0,i.jsx)(n.td,{children:"2.60"}),(0,i.jsx)(n.td,{children:"1.04"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(n.h3,{id:"wally",children:"Wally"}),"\n",(0,i.jsx)(n.p,{children:"The package name + version is"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ldgerrits/quickzone@^0.2.2\n"})}),"\n",(0,i.jsx)(n.h3,{id:"manual",children:"Manual"}),"\n",(0,i.jsxs)(n.p,{children:["Download the latest .rbxm model file from the ",(0,i.jsx)(n.a,{href:"https://github.com/LDGerrits/QuickZone/releases",children:"Releases"})," tab and drag it into ReplicatedStorage."]}),"\n",(0,i.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,i.jsx)(n.p,{children:"Here is a complete example of setting up a 'Water Zone' that enables swimming logic for the LocalPlayer."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local Players = game:GetService('Players')\nlocal ReplicatedStorage = game:GetService('ReplicatedStorage')\nlocal QuickZone = require(ReplicatedStorage.QuickZone)\n\n-- Create a LocalPlayerGroup that automatically tracks the client's character (including respawns)\nlocal myPlayer = QuickZone.LocalPlayerGroup()\n\n-- Create an Observer that holds the behavior with a priority of 42.\n-- If this player is inside multiple zones, the higher priority observer will 'win'.\nlocal swimObserver = QuickZone.Observer(42)\nswimObserver:subscribe(myPlayer)\n\n-- Connect the events (Note: Events return cleanup functions)\nswimObserver:onLocalPlayerEntered(function(zone)\n    print('LocalPlayer entered water!')\n    local char = Players.LocalPlayer.Character\n    if char then\n        char.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, true)\n        char.Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)\n    end\nend)\n\nswimObserver:onLocalPlayerExited(function(zone)\n    print('LocalPlayer left water.')\n    local char = Players.LocalPlayer.Character\n    if char then\n        char.Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)\n    end\nend)\n\n-- Create a static zone from a Part in workspace\nlocal poolZone = QuickZone.ZoneFromPart(workspace.PoolWater)\n\n-- Attach the logic (Observer) to the location (Zone)\npoolZone:attach(swimObserver)\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(6540);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);