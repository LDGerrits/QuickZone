"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[722],{60:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"usage","title":"Usage","description":"QuickZone is designed around a three-tier architecture: Zones (where), Groups (who), and Observers (how).","source":"@site/docs/usage.md","sourceDirName":".","slug":"/usage","permalink":"/QuickZone/docs/usage","draft":false,"unlisted":false,"editUrl":"https://github.com/LDgerrits/QuickZone/edit/main/docs/usage.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"defaultSidebar","previous":{"title":"Introduction","permalink":"/QuickZone/docs/intro"},"next":{"title":"Why use QuickZone?","permalink":"/QuickZone/docs/why-use-quickzone"}}');var i=r(4848),t=r(8453);const s={sidebar_position:2},o="Usage",l={},c=[{value:"The Two Workflows",id:"the-two-workflows",level:3},{value:"Style A: Declarative",id:"style-a-declarative",level:4},{value:"Style B: Imperative",id:"style-b-imperative",level:4},{value:"Zones",id:"zones",level:2},{value:"Creation",id:"creation",level:3},{value:"Manual Creation",id:"manual-creation",level:3},{value:"Updating Zones",id:"updating-zones",level:3},{value:"Groups",id:"groups",level:2},{value:"Specialized Groups",id:"specialized-groups",level:3},{value:"Custom Groups",id:"custom-groups",level:3},{value:"Managing Entities",id:"managing-entities",level:3},{value:"Observers",id:"observers",level:2},{value:"Setup",id:"setup",level:3},{value:"Lifecycle Management",id:"lifecycle-management",level:3},{value:"Events",id:"events",level:3},{value:"Priority and Resolution",id:"priority-and-resolution",level:3},{value:"Observer State",id:"observer-state",level:3},{value:"Utility",id:"utility",level:2},{value:"Frame Budget",id:"frame-budget",level:3},{value:"Immediate Spatial Queries",id:"immediate-spatial-queries",level:3},{value:"Debugging",id:"debugging",level:3},{value:"Considerations",id:"considerations",level:2}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"usage",children:"Usage"})}),"\n",(0,i.jsx)(n.p,{children:"QuickZone is designed around a three-tier architecture: Zones (where), Groups (who), and Observers (how)."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Priority",src:r(8445).A+"",width:"740",height:"460"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local QuickZone = require(game:GetService("ReplicatedStorage").QuickZone)\n\n-- We recommend assigning the classes to local variables\nlocal Zone = QuickZone.Zone\nlocal Observer = QuickZone.Observer\nlocal Group = QuickZone.Group\n'})}),"\n",(0,i.jsx)(n.h3,{id:"the-two-workflows",children:"The Two Workflows"}),"\n",(0,i.jsxs)(n.p,{children:["QuickZone offers two ways to structure your code: ",(0,i.jsx)(n.strong,{children:"Declarative"})," (Configuration-based) and ",(0,i.jsx)(n.strong,{children:"Imperative"})," (Chain-based)."]}),"\n",(0,i.jsx)(n.h4,{id:"style-a-declarative",children:"Style A: Declarative"}),"\n",(0,i.jsx)(n.p,{children:"Define your object's properties and its relationships in the constructors."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local localPlayerGroup = Group.localPlayer()\n\nlocal observer = Observer.new({\n    groups = { localPlayerGroup }, -- Immediately subscribes to these groups\n    priority = 1,\n})\n\nZone.fromPart(workspace.SafeZone, {\n    observers = { observer } -- Imediately attaches to these observers\n})\n"})}),"\n",(0,i.jsx)(n.h4,{id:"style-b-imperative",children:"Style B: Imperative"}),"\n",(0,i.jsx)(n.p,{children:"Create objects first, then link them together. You can do this at any point in their lifecycles."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local localPlayerGroup = Group.localPlayer()\nlocal observer = Observer.new({ priority = 1 })\nlocal zone = Zone.fromPart(workspace.SafeZone)\n\n-- Link them manually\nobserver:subscribe(localPlayerGroup)\nzone:attach(observer)\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"zones",children:"Zones"}),"\n",(0,i.jsx)(n.p,{children:"Zones represent physical areas in the world. They are mathematical boundaries that can be static (fixed in space) or dynamic (following a part). They can be created from existing parts or defined manually with a CFrame and Size."}),"\n",(0,i.jsx)(n.h3,{id:"creation",children:"Creation"}),"\n",(0,i.jsx)(n.p,{children:"The easiest way to create a zone."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Static Zone (Fastest)\n-- Ideal for shops, biomes, or permanent regions.\nlocal staticZones = Zone.fromParts(workspace.SafeZones:GetChildren())\n\n-- Dynamic Zone\n-- Passing 'true' makes the zone follow the part's CFrame on :update()\nlocal trainZone = Zone.fromPart(workspace.TrainCarriage, { \n    isDynamic = true,\n    metadata = { canDamage = true },\n    observers = { trainObserver }\n})\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Note: The third argument (",(0,i.jsx)(n.code,{children:"metadata"}),") is optional and can be retrieved using ",(0,i.jsx)(n.code,{children:"zone:getMetadata()"})]})}),"\n",(0,i.jsx)(n.h3,{id:"manual-creation",children:"Manual Creation"}),"\n",(0,i.jsx)(n.p,{children:"Useful for procedural generation or areas without physical parts."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local zone = Zone.new({\n    cframe = CFrame.new(0, 10, 0),\n    size = Vector3.new(10, 10, 10),\n    shape = 'Block',\n    isDynamic = true,\n    metadata = { Name = 'Lobby' }\n})\n"})}),"\n",(0,i.jsx)(n.admonition,{title:"Performance Optimization: Static vs. Dynamic",type:"info",children:(0,i.jsxs)(n.p,{children:["QuickZone batches tree rebuilds once per frame. By keeping the Dynamic Tree small, you make sure that these batched rebuilds remain super quick. For maximum perfomance, use ",(0,i.jsx)(n.code,{children:"isDynamic = true"})," for zones attached to moving platforms, vehicles, or projectiles."]})}),"\n",(0,i.jsx)(n.h3,{id:"updating-zones",children:"Updating Zones"}),"\n",(0,i.jsxs)(n.p,{children:["If you create a zone manually or want to sync a dynamic zone to a new reference, use ",(0,i.jsx)(n.code,{children:":syncToPart()"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Manually move a dynamic zone\ndynamicZone:setPosition(Vector3.new(0, 50, 0))\n\n-- Sync a dynamic zone to its associated part's current CFrame, Size, and Shape\ndynamicZone:syncToPart()\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"groups",children:"Groups"}),"\n",(0,i.jsx)(n.p,{children:"Groups are collections of entities (Parts, Models, Players, etc.). They allow you to categorize entities and set unique performance settings per category."}),"\n",(0,i.jsx)(n.h3,{id:"specialized-groups",children:"Specialized Groups"}),"\n",(0,i.jsx)(n.p,{children:"QuickZone provides built-in abstractions that automatically handle player lifecyles."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Tracks all players in the server\nlocal allPlayers = Group.players()\n\n-- Tracks only the local player (client-side only)\nlocal myPlayer = Group.localPlayer()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"custom-groups",children:"Custom Groups"}),"\n",(0,i.jsx)(n.p,{children:"For NPCs, projectiles, or vehicles, create a standard Group."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local projectiles = Group.new({\n    updateRate = 60,   -- Check every frame for high-speed objects\n    precision = 0,     -- Query every time it moves\n    entities = workspace.Projectiles:GetChildren()\n})\n\nlocal NPCs = Group.new({\n    updateRate = 5,    -- Check only 5 times a second\n    precision = 2.0    -- Only query if the NPC moves more than 2 studs\n})\n"})}),"\n",(0,i.jsx)(n.h3,{id:"managing-entities",children:"Managing Entities"}),"\n",(0,i.jsx)(n.p,{children:"You can add BaseParts, Models, Attachments, Bones, or tables with a Position."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Add a Model (tracks the PrimaryPart or Pivot)\n-- Note: 'metadata' applies to the entity, not the group.\nenemies:add(npcModel, { Team = 'Red' })\n\n-- Add a specific Attachment (tracks the exact point)\n-- This is great for offsets if you do not want to track the middle of a part (e.g. sword tip)\nenemies:add(sword.TipAttachment, { Damage = 75 })\n\n-- Add a table\nlocal spell = { Position = Vector3.new(10, 5, 0) }\nenemies:add(spell)\n\n-- Remove when done\nenemies:removeBulk({npcModel, sword.TipAttachment, spell})\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Note: The second argument (",(0,i.jsx)(n.code,{children:"metadata"}),") is optional and will be passed to your event callbacks."]})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"observers",children:"Observers"}),"\n",(0,i.jsx)(n.p,{children:"Observers act as the logic layer. They subscribe to Groups and attach to Zones to bridge spatial data with game behavior."}),"\n",(0,i.jsx)(n.h3,{id:"setup",children:"Setup"}),"\n",(0,i.jsx)(n.p,{children:"An Observer listens to its subscribed Groups and checks if they overlap with its attached Zones."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local observer = Observer.new()\n\nobserver:subscribe(allPlayers) -- Who to watch\nhealingZone:attach(observer)   -- Where to watch\n"})}),"\n",(0,i.jsx)(n.h3,{id:"lifecycle-management",children:"Lifecycle Management"}),"\n",(0,i.jsx)(n.p,{children:"For logic that should persist while an entity is inside a zone (e.g., UI, music, status effects), use the observe methods. These accept a callback that returns a cleanup function, which runs automatically when the entity exits."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Generic observation\nobserver:observe(function(entity, zone, metadata)\n    print("Entered", entity)\n    local highlight = Instance.new("Highlight", entity)\n    \n    return function()\n        print("Exited", entity)\n        highlight:Destroy()\n    end\nend)\n\n-- Player specific\nobserver:observePlayer(function(player, zone)\n    local forceField = Instance.new("ForceField", player.Character)\n    \n    return function()\n        forceField:Destroy()\n    end\nend)\n\n-- LocalPlayer specific\nobserver:observeLocalPlayer(function(zone)\n    local sound = workspace.Sounds.SafeZoneAmbience\n    sound:Play()\n\n    return function()\n        sound:Stop()\n    end\nend)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"events",children:"Events"}),"\n",(0,i.jsx)(n.p,{children:"For logic that happens exactly once on entry or exit (e.g., playing a sound effect, dealing damage, analytics), use the event listeners."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Fires when an entity enters a zone for this observer\nlocal enteredConn = observer:onEntered(function(entity, zone, metadata)\n    print(entity.Name .. ' entered ' .. zone:getId())\nend)\n\n-- Fires when an entity enters a zone for this observer\nlocal exitedConn = observer:onExited(function(entity, zone, metadata)\n    print(entity.Name .. ' exited ' .. zone:getId())\nend)\n\n-- Convenience wrappers\nobserver:onPlayerEntered(function(player, zone) ... end)\nobserver:onPlayerExited(function(player, zone) ... end)\nobserver:onLocalPlayerEntered(function(zone) ... end)\nobserver:onLocalPlayerExited(function(zone) ... end)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"priority-and-resolution",children:"Priority and Resolution"}),"\n",(0,i.jsx)(n.p,{children:"Observers use a priority system to handle overlapping zones. An entity 'belongs' to only one zone state per observer at a time when using priorities."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local lowPriority = Observer.new({ priority = 0 })\nlocal highPriority = Observer.new({ priority = 10 })\n\n-- If a player is inside Zone A (Low) and Zone B (High) simultaneously:\n-- 1. highPriority:onEntered() fires for Zone B.\n-- 2. lowPriority:onExited() fires for Zone A.\n"})}),"\n",(0,i.jsx)(n.h3,{id:"observer-state",children:"Observer State"}),"\n",(0,i.jsx)(n.p,{children:"Observers can be toggled to pause logic without destroying the configuration."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"observer:setEnabled(false) -- Fires 'onExited' for everyone inside\ntask.wait(5)\nobserver:setEnabled(true)  -- Fires 'onEntered' if they are still there\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"utility",children:"Utility"}),"\n",(0,i.jsx)(n.h3,{id:"frame-budget",children:"Frame Budget"}),"\n",(0,i.jsx)(n.p,{children:"To maintain a high framerate in complex scenes, you can constrain the total CPU time QuickZone is allowed to consume per frame."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Allow 0.5 milliseconds per frame (default is 1ms)\nQuickZone:setFrameBudget(0.5)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"immediate-spatial-queries",children:"Immediate Spatial Queries"}),"\n",(0,i.jsx)(n.p,{children:"Perform instant checks without using the Observer/Group pattern."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Get all zones at a specific vector\nlocal zones = QuickZone:getZonesAtPoint(Vector3.new(10, 5, 0))\n\n-- Get the group an entity belongs to\nlocal group = QuickZone:getGroupOfEntity(workspace.Part)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"debugging",children:"Debugging"}),"\n",(0,i.jsx)(n.p,{children:"Renders zones in the workspace to verify the setup."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"QuickZone:visualize(true)\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"considerations",children:"Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Point-Based Tracking:"})," QuickZone tracks the precise coordinate of an entity (Center, Attachment, or Pivot). It does not calculate the full volume intersection of the entity itself."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Movement Threshold (Precision)"}),": QuickZone only re-calculates spatial state when an entity moves beyond a certain distance. Setting a higher precision value (e.g., 2.0 studs) significantly reduces overhead for slow-moving objects."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Budgeted Latency"}),": To prevent frame drops, QuickZone 'smears' workload across multiple frames. In high-load scenarios (e.g., thousands of active entities), there may be a slight delay between an entity physically entering a zone and the event firing."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8445:(e,n,r)=>{r.d(n,{A:()=>a});const a=r.p+"assets/images/topology_quickzone-b84eba3dd758f5c1d6720894752a8021.png"},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var a=r(6540);const i={},t=a.createContext(i);function s(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);