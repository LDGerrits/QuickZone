{"searchDocs":[{"title":"QuickZone","type":0,"sectionRef":"#","url":"/QuickZone/api/QuickZone","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#types","content":" ","version":null,"tagName":"h2"},{"title":"ShapeType​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#ShapeType","content":"&lt;/&gt; type ShapeType = &quot;Block&quot; | &quot;Ball&quot; | &quot;Cylinder&quot; | &quot;Wedge&quot; | &quot;CornerWedge&quot; The geometric shape of a Zone.  ","version":null,"tagName":"h3"},{"title":"Entity​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#Entity","content":"&lt;/&gt; type Entity = BasePart | Model | Camera | Attachment | Bone | EntityTable An Entity is any object that can be tracked within a Group. It supports native Roblox Instances and custom duck-typed tables.  ","version":null,"tagName":"h3"},{"title":"EntityTable​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#EntityTable","content":"&lt;/&gt; interface EntityTable { Position: Vector3? WorldPosition: Vector3? CFrame: CFrame? GetPivot: (() → CFrame )? } A custom table that mimics the spatial properties of a Roblox Instance. QuickZone will automatically detect which property to use to track this entity. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#functions","content":" ","version":null,"tagName":"h2"},{"title":"setFrameBudget​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#setFrameBudget","content":"&lt;/&gt; QuickZone:setFrameBudget( ms: number-- Time in milliseconds ) → QuickZone Sets the global execution budget for the Scheduler per frame in milliseconds. The Scheduler will 'dispatch' entity updates until this threshold is reached, at which point it yields until the next frame to prevent render stutter. Defaults to 1ms. -- Allow QuickZone to use up to 0.5ms of frame time QuickZone:setFrameBudget(0.5)   ","version":null,"tagName":"h3"},{"title":"getZonesAtPoint​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getZonesAtPoint","content":"&lt;/&gt; QuickZone:getZonesAtPoint( position: Vector3 -- The world position to check. ) → {Zone} Performs a spatial query to find all Zones containing the given point.  ","version":null,"tagName":"h3"},{"title":"getObserversAtPoint​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getObserversAtPoint","content":"&lt;/&gt; QuickZone:getObserversAtPoint( position: Vector3 -- The world position to check. ) → {Observer} Finds all Observers whose assigned Zones contain the given point.  ","version":null,"tagName":"h3"},{"title":"getGroupOfEntity​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getGroupOfEntity","content":"&lt;/&gt; QuickZone:getGroupOfEntity( entity: Entity-- The Part, Model, or Table entity. ) → Group? Returns the Group that the specified entity currently belongs to.  ","version":null,"tagName":"h3"},{"title":"getZones​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getZones","content":"&lt;/&gt; QuickZone:getZones() → {Zone} Returns an array containing every Zone currently registered in the system. This includes both static and dynamic zones.  ","version":null,"tagName":"h3"},{"title":"getObservers​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getObservers","content":"&lt;/&gt; QuickZone:getObservers() → {Observer} Returns an array of all Observers currently existing in the system.  ","version":null,"tagName":"h3"},{"title":"getGroups​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getGroups","content":"&lt;/&gt; QuickZone:getGroups() → {Group} Returns an array of all Groups (including PlayerGroups) currently registered in the system.  ","version":null,"tagName":"h3"},{"title":"getEntities​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getEntities","content":"&lt;/&gt; QuickZone:getEntities() → {Entity} Returns a flattened array of every Entity (Parts, Models, etc.) currently being tracked across all Groups.  ","version":null,"tagName":"h3"},{"title":"visualize​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#visualize","content":"Debug &lt;/&gt; QuickZone:visualize( enabled: boolean-- Whether to show the debug visuals. ) → QuickZone Enables or disables visual rendering of all registered Zones. Static and Dynamic zones are colored differently based on their active status. ","version":null,"tagName":"h3"},{"title":"Group","type":0,"sectionRef":"#","url":"/QuickZone/api/Group","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#new","content":"Constructor &lt;/&gt; Group.new(config: { updateRate: number?, precision: number?, entities: {Types.Entity}? }?) → Group Creates a generic Group. Groups manage collections of Entities (any instance with a position in the world like BaseParts, Models, Attachments, etc.) that Observers should track. local myGroup = Group.new({ updateRate = 20, -- Check at 20Hz precision = 0.5, -- Ignore movement smaller than 0.5 studs entities = { NPC1, NPC2, NPC3 } -- Add entities })   ","version":null,"tagName":"h3"},{"title":"players​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#players","content":"Constructor &lt;/&gt; Group.players(config: { updateRate: number?, precision: number?, entities: {Types.Entity}? }?) → Group Returns a singleton Group that automatically tracks all Players in the server. Behavior Automatically tracks the HumanoidRootPart of every player. Handles PlayerAdded and CharacterAdded internally. If a LocalPlayerGroup exists on the client, the local player is excluded from this group to avoid duplicate tracking.   ","version":null,"tagName":"h3"},{"title":"localPlayer​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#localPlayer","content":"This item only works when running on the client. Client Constructor &lt;/&gt; Group.localPlayer(config: { updateRate: number?, precision: number?, entities: {Types.Entity}? }?) → Group Returns a singleton Group that tracks only the LocalPlayer. Behavior This group takes 'ownership of the local player's character. When this group is destroyed, the local player is automatically handed back to the global PlayerGroup if it exists.   ","version":null,"tagName":"h3"},{"title":"add​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#add","content":"&lt;/&gt; Group:add( entity: Entity,-- The object to track. metadata: any?-- Optional data passed to Observer callbacks. ) → Group Adds an entity to the group. If the entity is already in another group, it is automatically removed from the old one first. Example: Adding Different Entity Types -- Adding a BasePart and a Model with custom metadata (using chaining) myGroup:add(workspace.Part):add(workspace.NPCModel, { Type = 'Enemy', Level = 42 }) -- Adding a custom table local spell = { CFrame = CFrame.new(0, 10, 0), Name = 'Fireball' } myGroup:add(spell) Strategy Detection QuickZone automatically determines how to track the entity's position: BasePart: Uses Position Model: Uses PrimaryPart.Position or GetPivot() Attachment/Bone: Uses WorldPosition Camera: Uses CFrame Table: Looks for .Position, .CFrame, .WorldPosition, or :GetPivot().  ","version":null,"tagName":"h3"},{"title":"addBulk​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#addBulk","content":"&lt;/&gt; Group:addBulk( entities: {Entity},-- Array of entities to add. metadata: any?-- Optional metadata applied to all added entities. ) → Group Adds multiple entities to the group. -- Add an entire folder of NPCs at once myGroup:addBulk(workspace.Enemies:GetChildren(), { Team = &quot;Red&quot; })   ","version":null,"tagName":"h3"},{"title":"remove​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#remove","content":"&lt;/&gt; Group:remove(entity: Entity) → Group Removes the entity from the group.  ","version":null,"tagName":"h3"},{"title":"removeBulk​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#removeBulk","content":"&lt;/&gt; Group:removeBulk(entities: {Entity}) → Group Removes multiple entities from the group.  ","version":null,"tagName":"h3"},{"title":"clear​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#clear","content":"&lt;/&gt; Group:clear() → Group Removes all entities from the group. This fires 'onExited' events for every entity currently inside a zone.  ","version":null,"tagName":"h3"},{"title":"contains​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#contains","content":"&lt;/&gt; Group:contains(entity: Entity) → boolean Checks if a specific entity is currently a member of this group.  ","version":null,"tagName":"h3"},{"title":"setConfig​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#setConfig","content":"&lt;/&gt; Group:setConfig(config: { updateRate: number?, precision: number?, safety: boolean? }) → Group Updates the group's configuration. Precision A higher precision value (e.g., 2.0) means entities must move further before a re-calculation is triggered, improving performance for large groups.  ","version":null,"tagName":"h3"},{"title":"setUpdateRate​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#setUpdateRate","content":"&lt;/&gt; Group:setUpdateRate(updateRate: number) → Group Set the update rate of the group.  ","version":null,"tagName":"h3"},{"title":"setPrecision​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#setPrecision","content":"&lt;/&gt; Group:setPrecision(precision: number) → Group Set the current precision of the group.  ","version":null,"tagName":"h3"},{"title":"getConfig​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getConfig","content":"&lt;/&gt; Group:getConfig() → { updateRate: number, precision: number, safety: boolean } Returns the current configuration settings for the group.  ","version":null,"tagName":"h3"},{"title":"getUpdateRate​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getUpdateRate","content":"&lt;/&gt; Group:getUpdateRate() → number Returns the current update rate of the group.  ","version":null,"tagName":"h3"},{"title":"getPrecision​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getPrecision","content":"&lt;/&gt; Group:getPrecision() → number Returns the current precision of the group.  ","version":null,"tagName":"h3"},{"title":"getId​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getId","content":"&lt;/&gt; Group:getId() → number Returns the unique internal ID of the group.  ","version":null,"tagName":"h3"},{"title":"getEntities​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getEntities","content":"&lt;/&gt; Group:getEntities() → {Entity} Returns a list of all entities currently belonging to the group.  ","version":null,"tagName":"h3"},{"title":"getObservers​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getObservers","content":"&lt;/&gt; Group:getObservers() → {Observer} Returns a list of all Observers currently watching the group. local observers = myGroup:getObservers() print('This group is being watched by ' .. #observers .. ' observers.')   ","version":null,"tagName":"h3"},{"title":"destroy​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#destroy","content":"Destructor &lt;/&gt; Group:destroy() → () Cleans up the group, removes all tracked entities, and detaches any associated observers. ","version":null,"tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/QuickZone/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#overview","content":" QuickZone is a lightweight spatial library for Roblox that replaces expensive physics queries with fast, math-based entity tracking at scale. Instead of the physics engine, it uses geometric math while providing a predictable, budgeted, and flexible solution for zone detection, making it possible to track thousands of entities across hundreds of zones with very little impact on your frame rate.  Point-Based Detection QuickZone uses point-based detection. It checks if a specific point (e.g., the center of a Part, the position of an Attachment, or the Pivot of a Model) is inside a zone's boundary. Because it calculates if it is inside or not using geometric math instead of physics-based volume intersections, it is significantly faster than other zone detection libraries.    ","version":"Next","tagName":"h2"},{"title":"Core Features​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#core-features","content":" Lifecycle Management: Use the observe pattern for 100% reliable cleanup. There is no need for juggling onEntered and onExited events anymore (do note that QuickZone still supports Event-Driven Programming). Track Anything: Track BaseParts, Models, Attachments, Bones, Cameras, or even pure Lua tables. If it has a position, QuickZone can track it. Shape Support: Supports mathematical containment for Blocks, Balls, Cylinders, Wedges and CornerWedges without relying on physics collision meshes. Decoupled Architecture: Separate game logic from spatial instances. Bind behaviors to categories of entities (Players, NPCs, Projectiles) for a clean, scalable architecture. Budgeted Scheduler: Remove lag spikes by setting a hard frame budget (e.g., 1ms). Workload is smeared across frames to maintain a flat and predictable performance profile. Zero-Allocation Runtime: By using contiguous arrays and object pooling, QuickZone reduces GC pressure, avoiding memory-related stutters.    ","version":"Next","tagName":"h2"},{"title":"Performance Benchmarks​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#performance-benchmarks","content":" We stress-tested QuickZone against the most popular alternatives in two distinct scenarios: Entity Stress (lots of moving parts) and Map Stress (lots of zones).  Note: For the QuickZone benchmark, we used a frame budget of 1ms, the entities' update rate was set to 60Hz, and precision was 0.0.  ","version":"Next","tagName":"h2"},{"title":"Test 1: High Zone Count​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#test-1-high-zone-count","content":" Scenario: 500 moving entities, 10,000 zones, recorded over 30 seconds.  This test highlights the fundamental flaw in traditional Zone-Centric libraries. As map complexity grows, their performance degrades exponentially.  Metric\tQuickZone\tZonePlus\tSimpleZone\tQuickBounds\tEmpty ScriptFPS\t59.25\t3.84\t5.53\t58.95\t59.28 Events/s\t643\t627\t519\t328\t0 Memory Usage (MB)\t18.57\t4230\t99.79\t17.62\t0.65  The Result: QuickZone maintained a perfect 60 FPS.  ZonePlus and SimpleZone imploded, dropping to 3-5 FPS, making the game unplayable.ZonePlus consumed over 4 GB of memory, which would crash most mobile devices instantly.QuickZone proved it is O(N) relative to entities, not zones. You can add as many zones as you want without performance penalties.QuickZone vs. QuickBounds: Both libraries scaled well by maintaining ~60 FPS. However, QuickZone still maintained a slight FPS lead and, more importantly, delivered double the event throughput (643 vs 328) compared to QuickBounds.  ","version":"Next","tagName":"h3"},{"title":"Test 2: High Entity Count​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#test-2-high-entity-count","content":" Scenario: 2,000 moving entities, 100 zones, recorded over 30 seconds.  Metric\tQuickZone\tZonePlus\tSimpleZone\tQuickBounds\tEmpty ScriptFPS\t42.37\t29.88\t37.23\t41.31\t42.73 Events/s\t2271\t2482\t2518\t566\t0 Memory Usage (MB)\t2.13\t159\t1.77\t2.60\t1.04  The Result: QuickZone is the only library that maintained near-baseline FPS (-1% impact).  ZonePlus caused a 28% drop in framerate.QuickZone handled the load with 98% less memory than ZonePlus.QuickZone vs. QuickBounds: QuickZone squeezes out more performance, averaging ~1 FPS higher than QuickBounds. More importantly, QuickZone processed 4x the volume of events (2,271 vs 566).  ","version":"Next","tagName":"h3"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#installation","content":" ","version":"Next","tagName":"h2"},{"title":"Wally​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#wally","content":" The package name + version is  ldgerrits/quickzone@^0.4.1   ","version":"Next","tagName":"h3"},{"title":"Manual​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#manual","content":" Download the latest .rbxm model file from the Releases tab and drag it into ReplicatedStorage.  ","version":"Next","tagName":"h3"},{"title":"Quick Start​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#quick-start","content":" The following example showcases a swim system. QuickZone supports two coding styles, so choose the one that fits your workflow.  ","version":"Next","tagName":"h2"},{"title":"Option A: The QuickZone Approach (Recommended)​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#option-a-the-quickzone-approach-recommended","content":" Best for clean, modern code. You define relationships in a configuration table (Declarative) and use a single function to manage the active state (Lifecycle).  local QuickZone = require(game.ReplicatedStorage.QuickZone) local Zone, Group, Observer = QuickZone.Zone, QuickZone.Group, QuickZone.Observer -- Create a LocalPlayerGroup that automatically tracks the client's character (including respawns) local myPlayer = Group.localPlayer() -- Create an observer subscribed to that group. -- Priority 42 ensures this logic overrides lower-priority overlaps. local swimObserver = Observer.new({ priority = 42, groups = { myPlayer } }) -- Define behavior swimObserver:observeLocalPlayer(function() local chararcter = Players.LocalPlayer.Character if not character then return end local humanoid = character:FindFirstChild(&quot;Humanoid&quot;) if not humanoid then return end -- On Enter humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, true) humanoid:ChangeState(Enum.HumanoidStateType.Swimming) -- Return cleanup (On Exit) return function() humanoid:ChangeState(Enum.HumanoidStateType.GettingUp) end) end) -- Create zones based on parts inside workspace.WaterParts, -- and attach them to the observer automatically. -- This uses the declarative config pattern to attach everything in one step. Zone.fromParts(workspace.WaterParts:GetChildren(), { observers = { swimObserver } })   ","version":"Next","tagName":"h3"},{"title":"Option B: The Classic Approach (ZonePlus / SimpleZone Style)​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#option-b-the-classic-approach-zoneplus--simplezone-style","content":" Best for familiarity or for migrating ZonePlus code to QuickZone. You manually 'wire' objects together (Imperative) and use standard events like onEntered to trigger one-off actions (Event-Driven).  local QuickZone = require(game.ReplicatedStorage.QuickZone) local Zone, Group, Observer = QuickZone.Zone, QuickZone.Group, QuickZone.Observer local myPlayer = Group.localPlayer() local swimObserver = Observer.new({ priority = 42 }) -- Subscribe the logic to the group swimObserver:subscribe(myPlayer) -- Connect events swimObserver:onLocalPlayerEntered(function(zone) print(&quot;Entered water zone:&quot;, zone:getId()) -- Add swimming logic here end) swimObserver:onLocalPlayerExited(function(zone) print(&quot;Exited water zone:&quot;, zone:getId()) -- Remove swimming logic here end) -- Manually attach the zones local zones = Zone.fromParts(workspace.WaterParts:GetChildren()) for _, zone in zones do zone:attach(swimObserver) end  ","version":"Next","tagName":"h3"},{"title":"Why use QuickZone?","type":0,"sectionRef":"#","url":"/QuickZone/docs/why-use-quickzone","content":"","keywords":"","version":"Next"},{"title":"1. The Entity-Centric Model​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#1-the-entity-centric-model","content":" Traditional libraries are Zone-Centric. They iterate through every Zone instance and query the physics engine for overlapping parts (i.e. entities in QuickZone-terms).  The Scaling Problem: Performance worsens as you add more zones (O(Z)), even if the number of entities remains static.  QuickZone, on the other hand, is Entity-Centric. It keeps a list of entities and queries them against an LBVH (O(N log Z)).  The Benefit: This means that you can have hundreds, even thousands, of zones with very low runtime cost. The cost effectively becomes a factor of the number of entities that are being processed.    ","version":"Next","tagName":"h3"},{"title":"2. Data-Oriented Design (DOD)​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#2-data-oriented-design-dod","content":" QuickZone focuses on how data is laid out in memory based on DOD principles.  Contiguous Arrays: Unlike standard OOP where data is scattered across the heap in different objects, QuickZone stores entity data in pre-allocated, contiguous arrays to improve CPU cache locality. Stable Memory: By using flat arrays and object pooling, QuickZone generates almost no garbage during runtime. This prevents lag spikes caused by the GC.    ","version":"Next","tagName":"h3"},{"title":"3. Architecture​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#3-architecture","content":" QuickZone moves away from monolithic, instance-bound logic in favor of a Group-Observer-Zone topology. This architecture separates what is being tracked from where the tracking occurs and how the system should respond.    Groups​  A Group is a collection of entities that share performance characteristics and logical categorization. Performance can be configured per Group, like setting the update rate in Hz or the precision, i.e. the minimum distance threshold to perform a spatial query, in studs. This prevents wasting CPU cycles checking a slow-moving NPC, for example.  Observers​  Observers act as the logic bridge. They subscribe to Groups and are attach by Zones, creating a many-to-many relationship that keeps game logic decoupled and clean.  Because Observers are decoupled from the physics engine, they can aggregate spatial data. Tracking an entire Group costs no additional spatial queries.And using observeGroup(), an Observer can fire an event when the first member of a Group enters a zone, and clean up when the last member leaves.    ","version":"Next","tagName":"h3"},{"title":"4. The Budgeted Scheduler​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#4-the-budgeted-scheduler","content":" A common issue with spatial libraries is stutter due to it processing too many things in one frame. QuickZone fixes this via its smart Scheduler.  Frame Budgeting​  You can set a hard time limit (e.g., 1ms). The Scheduler monitors os.clock() in real-time. If the budget is met, the system pauses immediately and resumes in the next frame. This guarantees that QuickZone will never be the cause of a frame drop.  Workload Smearing​  The scheduler smears updates across frames. This means that, if you have a Group of 600 entities updating at 10Hz, QuickZone will process exactly 100 entities per frame at 60 fps. This ensures that we have flat, predictable performance profile with no peaks or valleys.  No starvation​  The Scheduler uses a Round-Robin strategy for Group processing. Instead of processing groups in order, QuickZone cycles through them fairly. This prevents the issue where a heavy group keeps consuming the entire frame budget and 'starving' the subsequent groups.    ","version":"Next","tagName":"h3"},{"title":"5. Dual-LBVH and Batched Rebuilding​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#5-dual-lbvh-and-batched-rebuilding","content":" To maintain high performance, QuickZone maintains two LBVHs:  The Static LBVH: Contains all non-moving, non-resizing zones. The Dynamic LBVH: Contains zones attached to moving parts (e.g., vehicles, platforms).  Optimization via Batching​  Rebuilding an LBVH is computationally expensive. QuickZone optimizes this by batching updates per frame: if multiple zones are added, removed, or moved in a single frame, QuickZone will only perform a single rebuild at the start of the Scheduler step.  By separating static and dynamic zones, QuickZone minimizes the workload of the LBVH rebuilder. Rebuilding a small tree of 5 moving platforms is significantly faster than rebuilding a tree containing 500 static buildings.  Frame budget Rebuilding the LBVHs is part of the frame budget. Thus, rebuilding will result in less time for processing the groups of entities.    ","version":"Next","tagName":"h3"},{"title":"6. Flexibility​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#6-flexibility","content":" Because QuickZone relies on pure math rather than the Physics engine, it is not limited to BaseParts. It also supports duck typing for entities.  BaseParts: Uses .Position. Models: Uses .PrimaryPart.Position or :GetPivot() (if .PrimaryPart does not exist). Attachments/Bones: Uses .WorldPosition. Cameras: Uses .CFrame.Position. Tables: Uses any custom .Position, .WorldPosition and .CFrame field, or :GetPivot().  This allows you to track real-time simulations (e.g. a spell cast or an RC car) without the overhead of creating physical Instances.    ","version":"Next","tagName":"h3"},{"title":"7. Performance Benchmarks​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#7-performance-benchmarks","content":" We stress-tested QuickZone against the most popular alternatives in two distinct scenarios: Entity Stress (lots of moving parts) and Map Stress (lots of zones).  Note: For the QuickZone benchmark, we used a frame budget of 1ms, the entities' update rate was set to 60Hz, and precision was 0.0.  ","version":"Next","tagName":"h3"},{"title":"Test 1: High Zone Count​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#test-1-high-zone-count","content":" Scenario: 500 moving entities, 10,000 zones, recorded over 30 seconds.  This test highlights the fundamental flaw in traditional Zone-Centric libraries. As map complexity grows, their performance degrades exponentially.  Metric\tQuickZone\tZonePlus\tSimpleZone\tQuickBounds\tEmpty ScriptFPS\t59.25\t3.84\t5.53\t58.95\t59.28 Events/s\t643\t627\t519\t328\t0 Memory Usage (MB)\t18.57\t4230\t99.79\t17.62\t0.65  The Result: QuickZone maintained a perfect 60 FPS.  ZonePlus and SimpleZone imploded, dropping to 3-5 FPS, making the game unplayable.ZonePlus consumed over 4 GB of memory, which would crash most mobile devices instantly.QuickZone proved it is O(N) relative to entities, not zones. You can add as many zones as you want without performance penalties.QuickZone vs. QuickBounds: Both libraries scaled well by maintaining ~60 FPS. However, QuickZone still maintained a slight FPS lead and, more importantly, delivered double the event throughput (643 vs 328) compared to QuickBounds.  ","version":"Next","tagName":"h3"},{"title":"Test 2: High Entity Count​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#test-2-high-entity-count","content":" Scenario: 2,000 moving entities, 100 zones, recorded over 30 seconds.  Metric\tQuickZone\tZonePlus\tSimpleZone\tQuickBounds\tEmpty ScriptFPS\t42.37\t29.88\t37.23\t41.31\t42.73 Events/s\t2271\t2482\t2518\t566\t0 Memory Usage (MB)\t2.13\t159\t1.77\t2.60\t1.04  The Result: QuickZone is the only library that maintained near-baseline FPS (-1% impact).  ZonePlus caused a 28% drop in framerate, rendering the game choppy.QuickZone handled the load with 98% less memory than ZonePlus.QuickZone vs. QuickBounds: QuickZone squeezes out more performance, averaging ~1 FPS higher than QuickBounds. More importantly, QuickZone processed 4x the volume of events (2,271 vs 566). ","version":"Next","tagName":"h3"},{"title":"Observer","type":0,"sectionRef":"#","url":"/QuickZone/api/Observer","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#new","content":"Constructor &lt;/&gt; Observer.new(config: { priority: number?, enabled: boolean?, safety: boolean?, groups: {Types.Group}?, }?) → Observer Creates an Observer. Observers listen for entities entering or exiting assigned Zones. local observer = QuickZone.Observer.new({ priority = 20, -- The priority value is used to resolve overlaps enabled = false, -- Observer will not start processing spatial checks safety = false, -- Do not wrap callbacks in task.spawn groups = { enemyGroup, playerGroup } -- Immediately subscribe to these groups }) Resolution Priority When an entity is inside multiple zones watched by different observers, higher priority observers take complete control.  ","version":null,"tagName":"h3"},{"title":"subscribe​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#subscribe","content":"&lt;/&gt; Observer:subscribe( group: Group-- The group to monitor. ) → Observer Links this observer to the specified group. The observer will only track entities that belong to subscribed groups. observer:subscribe(playerGroup):subscribe(enemyGroup)   ","version":null,"tagName":"h3"},{"title":"unsubscribe​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#unsubscribe","content":"&lt;/&gt; Observer:unsubscribe( group: Group-- The group to stop monitoring. ) → Observer Stops the observer from monitoring the specified group.  ","version":null,"tagName":"h3"},{"title":"observe​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#observe","content":"&lt;/&gt; Observer:observe(callback: ( entity: Entity, zone: Zone, metadata: any? ) → () → ()) → () → ()-- Function to stop observing entirely Observes entities entering and exiting the zone. The callback executes on entry and expects a function to be returned, which is executed on exit. observer:observe(function(entity, zone) print(&quot;Entered&quot;, entity) local highlight = Instance.new(&quot;Highlight&quot;, entity) -- Return cleanup function return function() print(&quot;Exited&quot;, entity) highlight:Destroy() end end)   ","version":null,"tagName":"h3"},{"title":"onEntered​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onEntered","content":"Event &lt;/&gt; Observer:onEntered(callback: ( entity: Entity, zone: Zone, metadata: any? ) → ()) → () → ()-- A function that, when called, disconnects the callback. Fires when any entity from a subscribed group enters a zone attached to this observer. local disconnect = observer:onEntered(function(entity, zone, metadata) print(entity.Name .. ' entered ' .. zone.id) end)   ","version":null,"tagName":"h3"},{"title":"onExited​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onExited","content":"Event &lt;/&gt; Observer:onExited(callback: ( entity: Entity, zone: Zone, metadata: any? ) → ()) → () → ()-- A function that, when called, disconnects the callback. Fires when an entity exits all zones attached to this observer.  ","version":null,"tagName":"h3"},{"title":"observePlayer​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#observePlayer","content":"&lt;/&gt; Observer:observePlayer(callback: ( player: Player , zone: Zone ) → (() → ())?) → () → ()-- Function to stop observing entirely. Observes players entering and exiting the zone. observer:observePlayer(function(player, zone) print(player.Name .. &quot; entered!&quot;) -- Return cleanup (optional) return function() print(player.Name .. &quot; left!&quot;) end end)   ","version":null,"tagName":"h3"},{"title":"onPlayerEntered​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onPlayerEntered","content":"Event &lt;/&gt; Observer:onPlayerEntered(callback: ( player: Player , zone: Zone ) → ()) → () → () Specialized event for Player entities. observer:onPlayerEntered(function(player, zone) print(player.Name .. &quot; entered safe zone &quot; .. zone:getId()) -- Play a sound local sound = workspace.Sounds.SafeZoneEnter:Clone() sound.Parent = player.Character.PrimaryPart sound:Play() game.Debris:AddItem(sound, 2) end)   ","version":null,"tagName":"h3"},{"title":"onPlayerExited​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onPlayerExited","content":"Event &lt;/&gt; Observer:onPlayerExited(callback: ( player: Player , zone: Zone ) → ()) → () → ()-- A function to disconnect the callback. A specialized event for Player entities. Fires when a player's character exits all zones attached to this observer.  ","version":null,"tagName":"h3"},{"title":"observeLocalPlayer​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#observeLocalPlayer","content":"This item only works when running on the client. Client &lt;/&gt; Observer:observeLocalPlayer(callback: (zone: Zone) → (() → ())?) → () → ()-- Function to stop observing entirely. Observes the LocalPlayer. observer:observeLocalPlayer(function(zone) local blur = Instance.new(&quot;BlurEffect&quot;, game.Lighting) return function() blur:Destroy() end end)   ","version":null,"tagName":"h3"},{"title":"onLocalPlayerEntered​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onLocalPlayerEntered","content":"This item only works when running on the client. Client Event &lt;/&gt; Observer:onLocalPlayerEntered(callback: (zone: Zone) → ()) → () → () Specialized event for the LocalPlayer. observer:onLocalPlayerEntered(function(zone) print(&quot;You entered zone &quot; .. zone:getId()) local char = player.Character if char and char:FindFirstChild(&quot;Humanoid&quot;) then char.Humanoid.WalkSpeed = 24 end end)   ","version":null,"tagName":"h3"},{"title":"onLocalPlayerExited​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onLocalPlayerExited","content":"This item only works when running on the client. Client Event &lt;/&gt; Observer:onLocalPlayerExited(callback: (zone: Zone) → ()) → () → () A specialized event for the LocalPlayer. Fires when the local player's character exits all zones attached to this observer.  ","version":null,"tagName":"h3"},{"title":"observeGroup​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#observeGroup","content":"&lt;/&gt; Observer:observeGroup(callback: ( group: Group, zone: Zone ) → (() → ())?) → () → () Observes a Group's presence within the observer's zones. The callback fires when the first entity of a group enters, and the returned cleanup function fires when the last entity of the group leaves. observer:observeGroup(function(group, zone) print(&quot;Group &quot; .. group:getId() .. &quot; has arrived!&quot;) return function() print(&quot;Group &quot; .. group:getId() .. &quot; has left entirely.&quot;) end end)   ","version":null,"tagName":"h3"},{"title":"onGroupEntered​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onGroupEntered","content":"Event &lt;/&gt; Observer:onGroupEntered(callback: ( group: Group, zone: Zone ) → ()) → () → ()-- Disconnect function Fires when the first member of a Group enters any zone attached to this observer. Subsequent entries by other members of the same group will not trigger this event until the group has completely exited and re-entered.  ","version":null,"tagName":"h3"},{"title":"onGroupExited​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onGroupExited","content":"Event &lt;/&gt; Observer:onGroupExited(callback: ( group: Group, zone: Zone ) → ()) → () → ()-- Disconnect function Fires when the last remaining member of a Group exits all zones attached to this observer. This is useful for &quot;cleared&quot; states or stopping group-wide effects.  ","version":null,"tagName":"h3"},{"title":"setEnabled​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#setEnabled","content":"&lt;/&gt; Observer:setEnabled(enabled: boolean) → Observer Enables or disables the observer. When disabled, it will no longer process spatial checks or fire events.  ","version":null,"tagName":"h3"},{"title":"setSafety​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#setSafety","content":"&lt;/&gt; Observer:setSafety(enabled: boolean) → Observer Whether to wrap callbacks in task.spawn (safe) or not (unsafe).  ","version":null,"tagName":"h3"},{"title":"setPriority​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#setPriority","content":"&lt;/&gt; Observer:setPriority(p: number) → Observer Updates the resolution priority of the observer.  ","version":null,"tagName":"h3"},{"title":"isEnabled​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isEnabled","content":"&lt;/&gt; Observer:isEnabled() → boolean Checks if the observer is currently enabled.  ","version":null,"tagName":"h3"},{"title":"isPlayerInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isPlayerInside","content":"&lt;/&gt; Observer:isPlayerInside(player: Player ) → boolean Checks if a specific player's character is currently inside a zone attached to this observer.  ","version":null,"tagName":"h3"},{"title":"isLocalPlayerInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isLocalPlayerInside","content":"This item only works when running on the client. Client &lt;/&gt; Observer:isLocalPlayerInside() → boolean Checks if the local player's character is currently inside a zone attached to this observer.  ","version":null,"tagName":"h3"},{"title":"isEntityInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isEntityInside","content":"&lt;/&gt; Observer:isEntityInside(entity: Entity) → boolean Checks if a specific entity is currently inside a zone attached to this observer.  ","version":null,"tagName":"h3"},{"title":"isPointInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isPointInside","content":"&lt;/&gt; Observer:isPointInside(position: Vector3 ) → boolean Checks if a specific point in world space is inside any zone attached to this observer.  ","version":null,"tagName":"h3"},{"title":"isSafe​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isSafe","content":"&lt;/&gt; Observer:isSafe() → boolean Checks if the observer wraps callbacks in task.spawn (safe) or not (unsafe).  ","version":null,"tagName":"h3"},{"title":"getId​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getId","content":"&lt;/&gt; Observer:getId() → number Returns the unique internal ID of the observer.  ","version":null,"tagName":"h3"},{"title":"getPriority​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getPriority","content":"&lt;/&gt; Observer:getPriority() → number Returns the current resolution priority.  ","version":null,"tagName":"h3"},{"title":"getEntitiesInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getEntitiesInside","content":"&lt;/&gt; Observer:getEntitiesInside() → {Entity} Returns a list of all tracked entities currently inside zones attached to this observer.  ","version":null,"tagName":"h3"},{"title":"getZones​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getZones","content":"&lt;/&gt; Observer:getZones() → {Zone} Returns the list of Zones currently attached to this observer.  ","version":null,"tagName":"h3"},{"title":"getGroups​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getGroups","content":"&lt;/&gt; Observer:getGroups() → {Group} Returns the list of Groups currently monitored by this observer.  ","version":null,"tagName":"h3"},{"title":"destroy​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#destroy","content":"Destructor &lt;/&gt; Observer:destroy() → () Cleans up the observer, disables tracking, and unsubscribes it from all groups and zones. ","version":null,"tagName":"h3"},{"title":"Zone","type":0,"sectionRef":"#","url":"/QuickZone/api/Zone","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#new","content":"Constructor &lt;/&gt; Zone.new(config: { cframe: CFrame , size: Vector3 , shape: Types.ShapeType?, part: BasePart? , isDynamic: boolean?, metadata: any?, observers: {Types.Observer}? }?) → Zone Creates a Zone object. local zone = QuickZone.Zone({ cframe = CFrame.new(0, 10, 0), size = Vector3.new(10, 10, 10), shape = 'Block', isDynamic = false, metadata = { Name = &quot;Lobby&quot; }, observers = { observer1, observer2 } }) Dynamic Zones If a zone moves, set isDynamic to true for maximum performance. Rebuild Request Requests a rebuild of corresponding tree (batched per frame).  ","version":null,"tagName":"h3"},{"title":"fromPart​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#fromPart","content":"Constructor &lt;/&gt; Zone.fromPart( part: BasePart ,-- The part to derive the zone from. config: { isDynamic: boolean?, metadata: any?, observers: {Types.Observer}? }? ) → Zone Creates a Zone automatically based on the Part's properties. Supported shapes: Block, Ball (Spheres), Cylinder, Wedge, and CornerWedge. local part = workspace.ZonePart local zone = QuickZone.Zone.fromPart(part, { observers = { safeObserver, healingObserver } }) Dynamic Zones If a zone moves, set isDynamic to true for maximum performance. Rebuild Request Requests a rebuild of corresponding tree (batched per frame).  ","version":null,"tagName":"h3"},{"title":"fromParts​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#fromParts","content":"Constructor &lt;/&gt; Zone.fromParts( parts: {BasePart },-- The parts to derive the zones from. config: { isDynamic: boolean?, metadata: any?, observers: {Types.Observer}? }? ) → {Zone} Create a list of zones corresponding to the list of BaseParts. Each zone corresponds to a BasePart and shares the same properties. local zones = QuickZone.Zone.fromParts(workspace.ZoneParts:GetChildren(), { isDynamic = false, observers = { mainObserver } }) Dynamic Zones If a zone moves, set isDynamic to true for maximum performance. Rebuild Request Requests a rebuild of corresponding tree (batched per frame).  ","version":null,"tagName":"h3"},{"title":"attach​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#attach","content":"&lt;/&gt; Zone:attach( observer: Observer-- The observer to link. ) → Zone Attaches an Observer to this zone. The observer will begin monitoring this area for entity overlaps. -- You are also able to chain calls zone:attach(damageObserver) :attach(visualObserver) :attach(soundObserver)   ","version":null,"tagName":"h3"},{"title":"detach​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#detach","content":"&lt;/&gt; Zone:detach( observer: Observer-- The observer to unlink. ) → Zone Detaches observer from this zone.  ","version":null,"tagName":"h3"},{"title":"syncToPart​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#syncToPart","content":"&lt;/&gt; Zone:syncToPart() → Zone Update the zone to the part's current CFrame, Size and Shape. Rebuild This method flags the zone for an update. The actual tree rebuild is batched and occurs once per frame. Static Zones: Expensive. Forces a rebuild of the main static tree. Dynamic Zones: Cheap. Forces a rebuild of the smaller dynamic tree.  ","version":null,"tagName":"h3"},{"title":"setCFrame​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#setCFrame","content":"&lt;/&gt; Zone:setCFrame(cf: CFrame ) → Zone Updates the Zone's CFrame. Rebuild Request Requests a rebuild of corresponding tree (batched per frame).  ","version":null,"tagName":"h3"},{"title":"setPosition​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#setPosition","content":"&lt;/&gt; Zone:setPosition(pos: Vector3 ) → Zone Updates the Zone's Position while preserving its current Rotation. Rebuild Request Requests a rebuild of corresponding tree (batched per frame).  ","version":null,"tagName":"h3"},{"title":"setSize​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#setSize","content":"&lt;/&gt; Zone:setSize(size: Vector3 ) → Zone Updates the Zone's Size. Rebuild Request Requests a rebuild of corresponding tree (batched per frame).  ","version":null,"tagName":"h3"},{"title":"setShape​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#setShape","content":"&lt;/&gt; Zone:setShape(shape: ShapeType) → Zone Updates the Zone's geometric shape.  ","version":null,"tagName":"h3"},{"title":"setMetadata​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#setMetadata","content":"&lt;/&gt; Zone:setMetadata() → number Set the metadata of the zone.  ","version":null,"tagName":"h3"},{"title":"getMetadata​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getMetadata","content":"&lt;/&gt; Zone:getMetadata() → number Returns the metadata of the zone.  ","version":null,"tagName":"h3"},{"title":"getId​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getId","content":"&lt;/&gt; Zone:getId() → number Returns the unique internal ID of the zone.  ","version":null,"tagName":"h3"},{"title":"getPart​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getPart","content":"&lt;/&gt; Zone:getPart() → BasePart?  Returns the BasePart associated with this zone, if any.  ","version":null,"tagName":"h3"},{"title":"getPosition​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getPosition","content":"&lt;/&gt; Zone:getPosition() → CFrame  Returns the current position of the zone.  ","version":null,"tagName":"h3"},{"title":"getCFrame​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getCFrame","content":"&lt;/&gt; Zone:getCFrame() → CFrame  Returns the current CFrame of the zone.  ","version":null,"tagName":"h3"},{"title":"getSize​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getSize","content":"&lt;/&gt; Zone:getSize() → Vector3  Returns the full size of the zone.  ","version":null,"tagName":"h3"},{"title":"getShape​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getShape","content":"&lt;/&gt; Zone:getShape() → ShapeType Returns the geometric shape type of the zone.  ","version":null,"tagName":"h3"},{"title":"getObservers​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getObservers","content":"&lt;/&gt; Zone:getObservers() → {Observer} Returns a list of all Observers currently attached to this zone.  ","version":null,"tagName":"h3"},{"title":"isPointInside​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#isPointInside","content":"&lt;/&gt; Zone:isPointInside(point: Vector3 ) → boolean Checks if a point is inside this specific zone.  ","version":null,"tagName":"h3"},{"title":"isDynamic​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#isDynamic","content":"&lt;/&gt; Zone:isDynamic() → boolean Returns whether the zone is currently registered as a dynamic object.  ","version":null,"tagName":"h3"},{"title":"destroy​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#destroy","content":"Destructor &lt;/&gt; Zone:destroy() → () Cleans up the zone, removes it from the LBVH tree, and detaches all observers. Rebuild Request Requests a rebuild of corresponding tree (batched per frame). ","version":null,"tagName":"h3"},{"title":"Usage","type":0,"sectionRef":"#","url":"/QuickZone/docs/usage","content":"","keywords":"","version":"Next"},{"title":"The Two Workflows​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#the-two-workflows","content":" QuickZone offers two ways to structure your code: Declarative (Configuration-based) and Imperative (Chain-based).  Style A: Declarative​  Define your object's properties and its relationships in the constructors.  local localPlayerGroup = Group.localPlayer() local observer = Observer.new({ groups = { localPlayerGroup }, -- Immediately subscribes to these groups priority = 1, }) Zone.fromPart(workspace.SafeZone, { observers = { observer } -- Immediately attaches to these observers })   Style B: Imperative​  Create objects first, then link them together. You can do this at any point in their lifecycles.  local localPlayerGroup = Group.localPlayer() local observer = Observer.new({ priority = 1 }) local zone = Zone.fromPart(workspace.SafeZone) -- Link them manually observer:subscribe(localPlayerGroup) zone:attach(observer)   ","version":"Next","tagName":"h3"},{"title":"1. Zones​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#1-zones","content":" Zones represent physical areas in the world. They are mathematical boundaries that can be static (fixed in space) or dynamic (following a part). They can be created from existing parts or defined manually with a CFrame and Size.  ","version":"Next","tagName":"h2"},{"title":"Creation​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#creation","content":" The easiest way to create a zone.  -- Static Zone (Fastest) -- Ideal for shops, biomes, or permanent regions. local staticZones = Zone.fromParts(workspace.SafeZones:GetChildren()) -- Dynamic Zone -- Passing 'true' makes the zone follow the part's CFrame on :update() local trainZone = Zone.fromPart(workspace.TrainCarriage, { isDynamic = true, metadata = { canDamage = true }, observers = { trainObserver } })   Note: The third argument (metadata) is optional and can be retrieved using zone:getMetadata()  ","version":"Next","tagName":"h3"},{"title":"Manual Creation​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#manual-creation","content":" Useful for procedural generation or areas without physical parts.  local zone = Zone.new({ cframe = CFrame.new(0, 10, 0), size = Vector3.new(10, 10, 10), shape = 'Block', isDynamic = true, metadata = { Name = 'Lobby' } })   Performance Optimization: Static vs. Dynamic QuickZone batches tree rebuilds once per frame. By keeping the Dynamic Tree small, you make sure that these batched rebuilds remain super quick. For maximum perfomance, use isDynamic = true for zones attached to moving platforms, vehicles, or projectiles.  ","version":"Next","tagName":"h3"},{"title":"Updating Zones​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#updating-zones","content":" If you create a zone manually or want to sync a dynamic zone to a new reference, use :syncToPart().  -- Manually move a dynamic zone dynamicZone:setPosition(Vector3.new(0, 50, 0)) -- Sync a dynamic zone to its associated part's current CFrame, Size, and Shape dynamicZone:syncToPart()   ","version":"Next","tagName":"h3"},{"title":"2. Groups​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#2-groups","content":" Groups are collections of entities (Parts, Models, Players, etc.). They allow you to categorize entities and set unique performance settings per category.  ","version":"Next","tagName":"h2"},{"title":"Specialized Groups​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#specialized-groups","content":" QuickZone provides built-in abstractions that automatically handle player lifecyles.  -- Tracks all players in the server local allPlayers = Group.players() -- Tracks only the local player (client-side only) local myPlayer = Group.localPlayer()   ","version":"Next","tagName":"h3"},{"title":"Custom Groups​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#custom-groups","content":" For NPCs, projectiles, or vehicles, create a standard Group.  local projectiles = Group.new({ updateRate = 60, -- Check every frame for high-speed objects precision = 0, -- Query every time it moves entities = workspace.Projectiles:GetChildren() }) local NPCs = Group.new({ updateRate = 5, -- Check only 5 times a second precision = 2.0 -- Only query if the NPC moves more than 2 studs })   ","version":"Next","tagName":"h3"},{"title":"Managing Entities​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#managing-entities","content":" You can add BaseParts, Models, Attachments, Bones, or tables with a Position.  -- Add a Model (tracks the PrimaryPart or Pivot) -- Note: 'metadata' applies to the entity, not the group. enemies:add(npcModel, { Team = 'Red' }) -- Add a specific Attachment (tracks the exact point) -- This is great for offsets if you do not want to track the middle of a part (e.g. sword tip) enemies:add(sword.TipAttachment, { Damage = 75 }) -- Add a table local spell = { Position = Vector3.new(10, 5, 0) } enemies:add(spell) -- Remove when done enemies:removeBulk({npcModel, sword.TipAttachment, spell})   Note: The second argument (metadata) is optional and will be passed to your event callbacks.  ","version":"Next","tagName":"h3"},{"title":"3. Observers​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#3-observers","content":" Observers act as the logic layer. They subscribe to Groups and attach to Zones to bridge spatial data with game behavior.  ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#setup","content":" An Observer listens to its subscribed Groups and checks if they overlap with its attached Zones.  local observer = Observer.new() observer:subscribe(allPlayers) -- Who to watch healingZone:attach(observer) -- Where to watch   ","version":"Next","tagName":"h3"},{"title":"Lifecycle Management​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#lifecycle-management","content":" For logic that should persist while an entity is inside a zone (e.g., UI, music, status effects), use the observe methods. These accept a callback that returns a cleanup function, which runs automatically when the entity exits.  -- Generic observation observer:observe(function(entity, zone, metadata) print(&quot;Entered&quot;, entity) local highlight = Instance.new(&quot;Highlight&quot;, entity) return function() print(&quot;Exited&quot;, entity) highlight:Destroy() end end) -- The callback fires when the first entity of a group enters, and the -- returned cleanup function fires when the last entity of the group leaves. observer:observeGroup(function(group, zone) print(&quot;Group &quot; .. group:getId() .. &quot; has arrived!&quot;) local boss = workspace.Boss:Clone() boss.Parent = workspace return function() print(&quot;The group has been wiped out or left.&quot;) boss:Destroy() end end) -- Player specific observer:observePlayer(function(player, zone) local forceField = Instance.new(&quot;ForceField&quot;, player.Character) return function() forceField:Destroy() end end) -- LocalPlayer specific observer:observeLocalPlayer(function(zone) local sound = workspace.Sounds.SafeZoneAmbience sound:Play() return function() sound:Stop() end end)   ","version":"Next","tagName":"h3"},{"title":"Events​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#events","content":" For logic that happens exactly once on entry or exit (e.g., playing a sound effect, dealing damage, analytics), use the event listeners.  -- Individual entity events observer:onEntered(function(entity, zone, metadata) print(entity.Name .. ' entered ' .. zone:getId()) end) observer:onExited(function(entity, zone, metadata) print(entity.Name .. ' exited ' .. zone:getId()) end) -- Group-level events observer:onGroupEntered(function(group, zone) print('The first member of group ' .. group:getId() .. ' entered!') end) observer:onGroupExited(function(group, zone) print('The last member of group ' .. group:getId() .. ' left!') end) -- Convenient player events observer:onPlayerEntered(function(player, zone) ... end) observer:onPlayerExited(function(player, zone) ... end) observer:onLocalPlayerEntered(function(zone) ... end) observer:onLocalPlayerExited(function(zone) ... end)   ","version":"Next","tagName":"h3"},{"title":"Priority and Resolution​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#priority-and-resolution","content":" Observers use a priority system to handle overlapping zones. An entity 'belongs' to only one zone state per observer at a time when using priorities.  local lowPriority = Observer.new({ priority = 0 }) local highPriority = Observer.new({ priority = 10 }) -- If a player is inside Zone A (Low) and Zone B (High) simultaneously: -- 1. highPriority:onEntered() fires for Zone B. -- 2. lowPriority:onExited() fires for Zone A.   ","version":"Next","tagName":"h3"},{"title":"Observer State​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#observer-state","content":" Observers can be toggled to pause logic without destroying the configuration.  observer:setEnabled(false) -- Fires 'onExited' for everyone inside task.wait(5) observer:setEnabled(true) -- Fires 'onEntered' if they are still there     ","version":"Next","tagName":"h3"},{"title":"Utility​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#utility","content":" ","version":"Next","tagName":"h2"},{"title":"Frame Budget​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#frame-budget","content":" To maintain a high framerate in complex scenes, you can constrain the total CPU time QuickZone is allowed to consume per frame.  -- Allow 0.5 milliseconds per frame (default is 1ms) QuickZone:setFrameBudget(0.5)   ","version":"Next","tagName":"h3"},{"title":"Immediate Spatial Queries​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#immediate-spatial-queries","content":" Perform instant checks without using the Observer/Group pattern.  -- Get all zones at a specific vector local zones = QuickZone:getZonesAtPoint(Vector3.new(10, 5, 0)) -- Get the group an entity belongs to local group = QuickZone:getGroupOfEntity(workspace.Part)     ","version":"Next","tagName":"h3"},{"title":"Considerations​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#considerations","content":" Point-Based Tracking: QuickZone tracks the precise coordinate of an entity (Center, Attachment, or Pivot). It does not calculate the full volume intersection of the entity itself. Movement Threshold (Precision): QuickZone only re-calculates spatial state when an entity moves beyond a certain distance. Setting a higher precision value (e.g., 2.0 studs) significantly reduces overhead for slow-moving objects. Budgeted Latency: To prevent frame drops, QuickZone 'smears' workload across multiple frames. In high-load scenarios (e.g., thousands of active entities), there may be a slight delay between an entity physically entering a zone and the event firing. ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}