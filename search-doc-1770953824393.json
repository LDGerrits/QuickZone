{"searchDocs":[{"title":"Group","type":0,"sectionRef":"#","url":"/QuickZone/api/Group","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#functions","content":" ","version":null,"tagName":"h2"},{"title":"add​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#add","content":"&lt;/&gt; Group:add( entity: Entity,-- The object to track. metadata: any?-- Optional data passed to Observer callbacks. ) → Group Adds an entity to the group. If the entity is already in another group, it is automatically removed from the old one first. Example: Adding Different Entity Types local myGroup = QuickZone.Group() -- Adding a BasePart myGroup:add(workspace.Part) -- Adding a Model with custom metadata myGroup:add(workspace.NPCModel, { Type = 'Enemy', Level = 42 }) -- Adding a custom table local spell = { CFrame = CFrame.new(0, 10, 0), Name = 'Fireball' } myGroup:add(spell) Strategy Detection QuickZone automatically determines how to track the entity's position: BasePart: Uses Position Model: Uses PrimaryPart.Position or GetPivot() Attachment/Bone: Uses WorldPosition Table: Looks for .Position, .CFrame, .WorldPosition, or :GetPivot().  ","version":null,"tagName":"h3"},{"title":"remove​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#remove","content":"&lt;/&gt; Group:remove( ...: Entity-- The entities to stop tracking. ) → Group Removes one or more entities from the group. -- Single removal myGroup:remove(workspace.Part) -- Multiple removal in one call myGroup:remove(partA, partB, modelC, spellTable)   ","version":null,"tagName":"h3"},{"title":"contains​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#contains","content":"&lt;/&gt; Group:contains(entity: Entity) → boolean Checks if a specific entity is currently a member of this group.  ","version":null,"tagName":"h3"},{"title":"setConfig​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#setConfig","content":"&lt;/&gt; Group:setConfig(config: { updateRate: number?, precision: number?, safety: boolean? }) → Group Updates the group's configuration at runtime. Precision A higher precision value (e.g., 2.0) means entities must move further before a re-calculation is triggered, improving performance for large groups.  ","version":null,"tagName":"h3"},{"title":"getConfig​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getConfig","content":"&lt;/&gt; Group:getConfig() → { updateRate: number, precision: number, safety: boolean } Returns the current configuration settings for this group. local config = myGroup:getConfig() print('Update Rate: ' .. config.updateRate .. 'Hz')   ","version":null,"tagName":"h3"},{"title":"getId​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getId","content":"&lt;/&gt; Group:getId() → number Returns the unique internal ID of this group.  ","version":null,"tagName":"h3"},{"title":"getEntities​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getEntities","content":"&lt;/&gt; Group:getEntities() → {Entity} Returns a list of all entities currently belonging to this group.  ","version":null,"tagName":"h3"},{"title":"getObservers​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#getObservers","content":"&lt;/&gt; Group:getObservers() → {Observer} Returns a list of all Observers currently watching this group. local observers = myGroup:getObservers() print('This group is being watched by ' .. #observers .. ' observers.')   ","version":null,"tagName":"h3"},{"title":"destroy​","type":1,"pageTitle":"Group","url":"/QuickZone/api/Group#destroy","content":"Destructor &lt;/&gt; Group:destroy() → () Cleans up the group, removes all tracked entities, and detaches any associated observers. ","version":null,"tagName":"h3"},{"title":"Zone","type":0,"sectionRef":"#","url":"/QuickZone/api/Zone","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#functions","content":" ","version":null,"tagName":"h2"},{"title":"attach​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#attach","content":"&lt;/&gt; Zone:attach( ...: Observer-- The observers to link. ) → Zone Attaches one or more Observers to this zone. The observers will begin monitoring this area for entity overlaps. zone:attach(myObserver)   ","version":null,"tagName":"h3"},{"title":"detach​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#detach","content":"&lt;/&gt; Zone:detach( ...: Observer-- The observers to unlink. ) → Zone Detaches observers from this zone.  ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#update","content":"&lt;/&gt; Zone:update( newCFrame: CFrame? ,-- Optional new position/rotation. newSize: Vector3? -- Optional new dimensions. ) → Zone Updates the zone's position and size. -- Manual update zone:update(CFrame.new(0, 20, 0), Vector3.new(5, 5, 5)) -- Sync with associated part zone:update() Auto-Sync If the zone was created with an associatedPart, calling update() without arguments will automatically sync the zone to that part's current CFrame and Size.  ","version":null,"tagName":"h3"},{"title":"getId​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getId","content":"&lt;/&gt; Zone:getId() → number Returns the unique internal ID of the zone.  ","version":null,"tagName":"h3"},{"title":"getPart​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getPart","content":"&lt;/&gt; Zone:getPart() → BasePart?  Returns the BasePart associated with this zone, if any.  ","version":null,"tagName":"h3"},{"title":"getShapeType​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getShapeType","content":"&lt;/&gt; Zone:getShapeType() → ShapeType Returns the geometric shape type of the zone.  ","version":null,"tagName":"h3"},{"title":"getObservers​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#getObservers","content":"&lt;/&gt; Zone:getObservers() → {Observer} Returns a list of all Observers currently attached to this zone.  ","version":null,"tagName":"h3"},{"title":"isPointInside​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#isPointInside","content":"&lt;/&gt; Zone:isPointInside(point: Vector3 ) → boolean Checks if a point is inside this specific zone.  ","version":null,"tagName":"h3"},{"title":"isDynamic​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#isDynamic","content":"&lt;/&gt; Zone:isDynamic() → boolean Returns whether the zone is currently registered as a dynamic object.  ","version":null,"tagName":"h3"},{"title":"destroy​","type":1,"pageTitle":"Zone","url":"/QuickZone/api/Zone#destroy","content":"Destructor &lt;/&gt; Zone:destroy() → () Cleans up the zone, removes it from the BVH tree, and detaches all observers. ","version":null,"tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/QuickZone/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#overview","content":" QuickZone is a high-performance, spatial partitioning library for Roblox.  QuickZone makes it possible to track thousands of entities across hundreds of zones with almost no impact on your frame rate. It bypasses Roblox's physics engine in favor of geometric math while providing a predictable, budgeted, and flexible solution for zone detection.  Point-Based Detection QuickZone uses point-based detection. It checks if a specific point (e.g., the center of a Part, the position of an Attachment, or the Pivot of a Model) is inside a zone's boundary. Because it calculates if it is inside or not using geometric math instead of physics-based volume intersections, it is significantly faster than other zone detection libraries.  ","version":"Next","tagName":"h2"},{"title":"Core Features​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#core-features","content":" Fast Spatial Queries: Process thousands of spatial queries per second with negligible FPS impact. Track Anything: Track BaseParts, Models, Attachments, Bones, Cameras, or even pure Lua tables. If it has a position, QuickZone can track it. Shape Support: Supports mathematical containment for Blocks, Balls, Cylinders, and Wedges without relying on physics collision meshes. Decoupled Logic: Decouple game logic from spatial instances. Bind behaviors to categories of entities (Players, NPCs, Projectiles) for a clean, scalable architecture. Budgeted Scheduler: Remove lag spikes by setting a hard frame budget (e.g., 1ms). Workload is smeared across frames to ensure a flat, predictable performance profile. Zero-Allocation Runtime: Engineered with Data-Oriented Design to minimize GC pressure. By using contiguous arrays and object pooling, QuickZone avoids memory-related stutters.  ","version":"Next","tagName":"h2"},{"title":"Benchmarks​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#benchmarks","content":" In a scenario with 2,000 moving entities and 100 zones recorded over 30-seconds, the obtained benchmarks were as follows:  Metric\tQuickZone\tZonePlus\tSimpleZone\tQuickBounds\tEmpty ScriptFPS\t42.37\t37.23\t29.88\t41.31\t42.73 Events/s\t2271\t2482\t2518\t566\t0 Memory Usage (MB)\t2.13\t159\t1.77\t2.60\t1.04  ","version":"Next","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#installation","content":" ","version":"Next","tagName":"h2"},{"title":"Wally​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#wally","content":" The package name + version is  ldgerrits/quickzone@^0.2.2   ","version":"Next","tagName":"h3"},{"title":"Manual​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#manual","content":" Download the latest .rbxm model file from the Releases tab and drag it into ReplicatedStorage.  ","version":"Next","tagName":"h3"},{"title":"Quick Start​","type":1,"pageTitle":"Introduction","url":"/QuickZone/docs/intro#quick-start","content":" Here is a complete example of setting up a 'Water Zone' that enables swimming logic for the LocalPlayer.  local Players = game:GetService('Players') local ReplicatedStorage = game:GetService('ReplicatedStorage') local QuickZone = require(ReplicatedStorage.QuickZone) -- Create a LocalPlayerGroup that automatically tracks the client's character (including respawns) local myPlayer = QuickZone.LocalPlayerGroup() -- Create an Observer that holds the behavior with a priority of 42. -- If this player is inside multiple zones, the higher priority observer will 'win'. local swimObserver = QuickZone.Observer(42) swimObserver:subscribe(myPlayer) -- Connect the events (Note: Events return cleanup functions) swimObserver:onLocalPlayerEntered(function(zone) print('LocalPlayer entered water!') local char = Players.LocalPlayer.Character if char then char.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, true) char.Humanoid:ChangeState(Enum.HumanoidStateType.Swimming) end end) swimObserver:onLocalPlayerExited(function(zone) print('LocalPlayer left water.') local char = Players.LocalPlayer.Character if char then char.Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp) end end) -- Create a static zone from a Part in workspace local poolZone = QuickZone.ZoneFromPart(workspace.PoolWater) -- Attach the logic (Observer) to the location (Zone) poolZone:attach(swimObserver)  ","version":"Next","tagName":"h2"},{"title":"QuickZone","type":0,"sectionRef":"#","url":"/QuickZone/api/QuickZone","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#types","content":" ","version":null,"tagName":"h2"},{"title":"ShapeType​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#ShapeType","content":"&lt;/&gt; type ShapeType = &quot;Block&quot; | &quot;Ball&quot; | &quot;Cylinder&quot; | &quot;Wedge&quot; | &quot;CornerWedge&quot; Represents the geometric volume of a Zone.  ","version":null,"tagName":"h3"},{"title":"Entity​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#Entity","content":"&lt;/&gt; type Entity = BasePart | Model | Camera | Attachment | Bone | EntityTable An Entity is any object that can be tracked within a Group. Supports native Roblox Instances and custom &quot;duck-typed&quot; tables.  ","version":null,"tagName":"h3"},{"title":"EntityTable​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#EntityTable","content":"&lt;/&gt; interface EntityTable { Position: Vector3? WorldPosition: Vector3? CFrame: CFrame? GetPivot: (() → CFrame )? } A custom table that mimics the spatial properties of a Roblox Instance. QuickZone will automatically detect which property to use to track this entity. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#functions","content":" ","version":null,"tagName":"h2"},{"title":"Zone​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#Zone","content":"Constructor &lt;/&gt; QuickZone.Zone( cframe: CFrame ,-- The center position and orientation of the zone. size: Vector3 ,-- The shape of the zone. shape: ShapeType,-- The geometric shape ('Block', 'Ball', 'Cylinder', etc). associatedPart: BasePart? ,-- An optional part to associate with this zone. isDynamic: boolean?-- Whether the zone moves or changes size frequently. ) → Zone Creates a Zone object. local zone = QuickZone.Zone( CFrame.new(0, 10, 0), Vector3.new(10, 10, 10), 'Block', nil, false -- Static ) Performance If this zone moves (e.g., attached to a moving platform) or changes size, you must set isDynamic to true. Static zones are optimized into a large, pre-calculated tree. Updating a static zone forces a full recalculation of that tree, which is expensive. Dynamic zones are handled separately and are much cheaper to update.  ","version":null,"tagName":"h3"},{"title":"ZoneFromPart​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#ZoneFromPart","content":"Constructor &lt;/&gt; QuickZone.ZoneFromPart( part: BasePart ,-- The part to derive the zone from. isDynamic: boolean?-- Whether the zone should follow the part every frame. ) → Zone Creates a Zone automatically based on a Part's properties. Supported shapes: Block, Ball (Spheres), Cylinder, and Wedge.  ","version":null,"tagName":"h3"},{"title":"Observer​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#Observer","content":"Constructor &lt;/&gt; QuickZone.Observer( priority: number?-- The priority level (defaults to 0). ) → Observer Creates an Observer. Observers listen for entities entering or exiting assigned Zones. Resolution Priority The priority value is used to resolve overlaps. When an entity is inside multiple zones watched by different observers, higher priority observers take precedence in specific logic chains.  ","version":null,"tagName":"h3"},{"title":"Group​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#Group","content":"Constructor &lt;/&gt; QuickZone.Group(config: { updateRate: number?, precision: number?, safety: boolean? }?) → Group Creates a generic Group. Groups manage collections of Entities (any instance with a position in the world like BaseParts, Models, Attachments, etc.) that Observers should track. local myGroup = QuickZone.Group({ updateRate = 20, -- Check at 20Hz precision = 0.5, -- Ignore movement smaller than 0.5 studs safety = true -- Wrap callbacks in task.spawn })   ","version":null,"tagName":"h3"},{"title":"PlayerGroup​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#PlayerGroup","content":"Constructor &lt;/&gt; QuickZone.PlayerGroup(config: { updateRate: number?, precision: number?, safety: boolean? }?) → Group Returns a singleton Group that automatically tracks all Players in the server. Behavior Automatically tracks the HumanoidRootPart of every player. Handles PlayerAdded and CharacterAdded internally. If a LocalPlayerGroup exists on the client, the local player is excluded from this group to avoid duplicate tracking.   ","version":null,"tagName":"h3"},{"title":"LocalPlayerGroup​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#LocalPlayerGroup","content":"This item only works when running on the client. Client Constructor &lt;/&gt; QuickZone.LocalPlayerGroup(config: { updateRate: number?, precision: number?, safety: boolean? }?) → Group Returns a singleton Group that tracks only the LocalPlayer. Behavior This group takes 'ownership of the local player's character. When this group is destroyed, the local player is automatically handed back to the global PlayerGroup if it exists.   ","version":null,"tagName":"h3"},{"title":"setFrameBudget​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#setFrameBudget","content":"&lt;/&gt; QuickZone:setFrameBudget( n: number-- Time in milliseconds. ) → QuickZone Sets the global time budget (in milliseconds) for the Scheduler per frame. Defaults to 1ms. Use this to prevent frame drops in heavy games. -- Allow QuickZone to use up to 5ms of frame time QuickZone:setFrameBudget(5)   ","version":null,"tagName":"h3"},{"title":"getZonesAtPoint​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getZonesAtPoint","content":"&lt;/&gt; QuickZone:getZonesAtPoint( position: Vector3 -- The world position to check. ) → {Zone} Performs a spatial query to find all Zones containing the given point.  ","version":null,"tagName":"h3"},{"title":"getObserversAtPoint​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getObserversAtPoint","content":"&lt;/&gt; QuickZone:getObserversAtPoint( position: Vector3 -- The world position to check. ) → {Observer} Finds all Observers whose assigned Zones contain the given point.  ","version":null,"tagName":"h3"},{"title":"getGroupOfEntity​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getGroupOfEntity","content":"&lt;/&gt; QuickZone:getGroupOfEntity( entity: Entity-- The Part, Model, or Table entity. ) → Group? Returns the Group that the specified entity currently belongs to.  ","version":null,"tagName":"h3"},{"title":"getZones​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getZones","content":"&lt;/&gt; QuickZone:getZones() → {Zone} Returns an array containing every Zone currently registered in the system. This includes both static and dynamic zones.  ","version":null,"tagName":"h3"},{"title":"getObservers​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getObservers","content":"&lt;/&gt; QuickZone:getObservers() → {Observer} Returns an array of all Observers currently existing in the system.  ","version":null,"tagName":"h3"},{"title":"getGroups​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getGroups","content":"&lt;/&gt; QuickZone:getGroups() → {Group} Returns an array of all Groups (including PlayerGroups) currently registered in the system.  ","version":null,"tagName":"h3"},{"title":"getEntities​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#getEntities","content":"&lt;/&gt; QuickZone:getEntities() → {Entity} Returns a flattened array of every Entity (Parts, Models, etc.) currently being tracked across all Groups.  ","version":null,"tagName":"h3"},{"title":"visualize​","type":1,"pageTitle":"QuickZone","url":"/QuickZone/api/QuickZone#visualize","content":"Debug &lt;/&gt; QuickZone:visualize( enabled: boolean-- Whether to show the debug visuals. ) → QuickZone Enables or disables visual rendering of all registered Zones. Static and Dynamic zones are colored differently based on their active status. ","version":null,"tagName":"h3"},{"title":"Observer","type":0,"sectionRef":"#","url":"/QuickZone/api/Observer","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#functions","content":" ","version":null,"tagName":"h2"},{"title":"subscribe​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#subscribe","content":"&lt;/&gt; Observer:subscribe( ...: Group-- The groups to monitor. ) → Observer Links this observer to one or more entity groups. The observer will only track entities that belong to subscribed groups. observer:subscribe(QuickZone.PlayerGroup())   ","version":null,"tagName":"h3"},{"title":"unsubscribe​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#unsubscribe","content":"&lt;/&gt; Observer:unsubscribe( ...: Group-- The groups to stop monitoring. ) → Observer Stops the observer from monitoring the specified groups.  ","version":null,"tagName":"h3"},{"title":"onEntered​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onEntered","content":"Event &lt;/&gt; Observer:onEntered(callback: ( entity: Entity, zone: Zone, metadata: any? ) → ()) → () → ()-- A function that, when called, disconnects the callback. Fires when any entity from a subscribed group enters a zone attached to this observer. local disconnect = observer:onEntered(function(entity, zone, metadata) print(entity.Name .. ' entered ' .. zone.id) end)   ","version":null,"tagName":"h3"},{"title":"onExited​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onExited","content":"Event &lt;/&gt; Observer:onExited(callback: ( entity: Entity, zone: Zone, metadata: any? ) → ()) → () → ()-- A function that, when called, disconnects the callback. Fires when an entity exits all zones attached to this observer.  ","version":null,"tagName":"h3"},{"title":"onPlayerEntered​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onPlayerEntered","content":"Event &lt;/&gt; Observer:onPlayerEntered(callback: ( player: Player , zone: Zone ) → ()) → () → () Specialized event for Player entities.  ","version":null,"tagName":"h3"},{"title":"onPlayerExited​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onPlayerExited","content":"Event &lt;/&gt; Observer:onPlayerExited(callback: ( player: Player , zone: Zone ) → ()) → () → ()-- A function to disconnect the callback. A specialized event for Player entities. Fires when a player's character exits all zones attached to this observer.  ","version":null,"tagName":"h3"},{"title":"onLocalPlayerEntered​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onLocalPlayerEntered","content":"This item only works when running on the client. Client Event &lt;/&gt; Observer:onLocalPlayerEntered(callback: (zone: Zone) → ()) → () → () Specialized event for the LocalPlayer.  ","version":null,"tagName":"h3"},{"title":"onLocalPlayerExited​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#onLocalPlayerExited","content":"This item only works when running on the client. Client Event &lt;/&gt; Observer:onLocalPlayerExited(callback: (zone: Zone) → ()) → () → () A specialized event for the LocalPlayer. Fires when the local player's character exits all zones attached to this observer.  ","version":null,"tagName":"h3"},{"title":"setEnabled​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#setEnabled","content":"&lt;/&gt; Observer:setEnabled(enabled: boolean) → Observer Enables or disables the observer. When disabled, it will no longer process spatial checks or fire events.  ","version":null,"tagName":"h3"},{"title":"setPriority​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#setPriority","content":"&lt;/&gt; Observer:setPriority(p: number) → Observer Updates the resolution priority of the observer.  ","version":null,"tagName":"h3"},{"title":"isEnabled​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isEnabled","content":"&lt;/&gt; Observer:isEnabled() → boolean Checks if the observer is currently enabled.  ","version":null,"tagName":"h3"},{"title":"isPlayerInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isPlayerInside","content":"&lt;/&gt; Observer:isPlayerInside(player: Player ) → boolean Checks if a specific player's character is currently inside a zone attached to this observer.  ","version":null,"tagName":"h3"},{"title":"isLocalPlayerInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isLocalPlayerInside","content":"This item only works when running on the client. Client &lt;/&gt; Observer:isLocalPlayerInside() → boolean Checks if the local player's character is currently inside a zone attached to this observer.  ","version":null,"tagName":"h3"},{"title":"isEntityInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isEntityInside","content":"&lt;/&gt; Observer:isEntityInside(entity: Entity) → boolean Checks if a specific entity is currently inside a zone attached to this observer.  ","version":null,"tagName":"h3"},{"title":"isPointInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#isPointInside","content":"&lt;/&gt; Observer:isPointInside(position: Vector3 ) → boolean Checks if a specific point in world space is inside any zone attached to this observer.  ","version":null,"tagName":"h3"},{"title":"getId​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getId","content":"&lt;/&gt; Observer:getId() → number Returns the unique internal ID of the observer.  ","version":null,"tagName":"h3"},{"title":"getPriority​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getPriority","content":"&lt;/&gt; Observer:getPriority() → number Returns the current resolution priority.  ","version":null,"tagName":"h3"},{"title":"getEntitiesInside​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getEntitiesInside","content":"&lt;/&gt; Observer:getEntitiesInside() → {Entity} Returns a list of all tracked entities currently inside zones attached to this observer.  ","version":null,"tagName":"h3"},{"title":"getZones​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getZones","content":"&lt;/&gt; Observer:getZones() → {Zone} Returns the list of Zones currently attached to this observer.  ","version":null,"tagName":"h3"},{"title":"getGroups​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#getGroups","content":"&lt;/&gt; Observer:getGroups() → {Group} Returns the list of Groups currently monitored by this observer.  ","version":null,"tagName":"h3"},{"title":"destroy​","type":1,"pageTitle":"Observer","url":"/QuickZone/api/Observer#destroy","content":"Destructor &lt;/&gt; Observer:destroy() → () Cleans up the observer, disables tracking, and unsubscribes it from all groups and zones. ","version":null,"tagName":"h3"},{"title":"Usage","type":0,"sectionRef":"#","url":"/QuickZone/docs/usage","content":"","keywords":"","version":"Next"},{"title":"Zones​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#zones","content":" Zones represent physical areas in the world. They are mathematical boundaries that can be static (fixed in space) or dynamic (following a part). They can be created from existing parts or defined manually with a CFrame and Size.  ","version":"Next","tagName":"h2"},{"title":"Creation​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#creation","content":" The easiest way to create a zone.  -- Static Zone (Fastest) -- Ideal for shops, biomes, or permanent regions. local staticZone = QuickZone.ZoneFromPart(workspace.SafeZone) -- Dynamic Zone -- Passing 'true' makes the zone follow the part's CFrame on :update() local trainZone = QuickZone.ZoneFromPart(workspace.TrainCarriage, true)   ","version":"Next","tagName":"h3"},{"title":"Manual Creation​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#manual-creation","content":" Useful for procedural generation or areas without physical parts.  local zone = QuickZone.Zone( CFrame.new(0, 10, 0), -- Position and rotation Vector3.new(20, 20, 20), -- Size 'Block', -- Shape: 'Block', 'Ball', 'Cylinder', or 'Wedge' nil, -- No associated part false -- Static (false) or dynamic (true) )   ","version":"Next","tagName":"h3"},{"title":"Updating Zones​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#updating-zones","content":" If you create a zone manually or want to sync a dynamic zone to a new reference, use :update().  -- Manually move a zone zone:update(CFrame.new(0, 50, 0), Vector3.new(10, 10, 10)) -- Sync a dynamic zone to its associated part dynamicZone:update()   ","version":"Next","tagName":"h3"},{"title":"Groups​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#groups","content":" Groups are collections of entities (Parts, Models, Players, etc.) that you want to track. They allow you to categorize entities and set unique performance costs for each category.  ","version":"Next","tagName":"h2"},{"title":"Specialized Groups​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#specialized-groups","content":" QuickZone provides specialized groups that automatically handle player joining, leaving, and respawning.  -- Tracks all players in the server local allPlayers = QuickZone.PlayerGroup() -- Tracks only the local player (client-side only) local myPlayer = QuickZone.LocalPlayerGroup()   ","version":"Next","tagName":"h3"},{"title":"Custom Groups​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#custom-groups","content":" For NPCs, projectiles, or vehicles, create a standard Group.  local projectiles = QuickZone.Group({ updateRate = 60, -- Check every frame for high-speed objects precision = 0, -- Query every time it moves safety = false -- Fire callbacks immediately (faster but risky if you yield) }) local idleNPCs = QuickZone.Group({ updateRate = 5, -- Check only 5 times a second precision = 2.0 -- Only query if the NPC moves more than 2 studs })   ","version":"Next","tagName":"h3"},{"title":"Adding Entities​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#adding-entities","content":" You can add BaseParts, Models, Attachments, Bones, or even tables with a Position.  -- Add a Model (tracks the PrimaryPart or Pivot) enemies:add(npcModel, { Team = 'Red' }) -- Add a specific Attachment (tracks the exact point) -- This is great for offsets if you do not want to track the middle of a part (e.g. sword tip) enemies:add(sword.TipAttachment, { Damage = 75 }) -- Add a table local spell = { Position = Vector3.new(10, 5, 0) } enemies:add(spell) -- Remove when done enemies:remove(npcModel)   Note: The second argument (metadata) is optional and will be passed to your event callbacks.  ","version":"Next","tagName":"h3"},{"title":"Observers​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#observers","content":" Observers are the 'brain' of QuickZone. They connect Groups to Zones.  ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#setup","content":" An Observer listens to its subscribed Groups and checks if they overlap with its attached Zones.  local observer = QuickZone.Observer() observer:subscribe(allPlayers) -- Who to watch healingZone:attach(observer) -- Where to watch   ","version":"Next","tagName":"h3"},{"title":"Events​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#events","content":" Events are defined on the Observer, not the Zone or Group. Events return a cleanup function. Calling this function is equivalent to 'disconnecting' the listener.  -- Fires when an entity enters a zone for this observer local disconnect = observer:onEntered(function(entity, zone, metadata) print(entity.Name .. &quot; entered &quot; .. zone:getId()) end) -- Convenience Player wrappers observer:onPlayerEntered(function(player, zone) ... end) observer:onLocalPlayerEntered(function(zone) ... end) observer:onPlayerExited(function(player, zone) ... end)   ","version":"Next","tagName":"h3"},{"title":"Priority & Resolution​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#priority--resolution","content":" Observers use a priority system to handle overlapping zones. An entity 'belongs' to only one zone state per observer at a time when using priorities.  local lowPriority = QuickZone.Observer(0) local highPriority = QuickZone.Observer(10) -- If a player is inside Zone A (Low) and Zone B (High) simultaneously: -- 1. highPriority:onEntered() fires for Zone B. -- 2. lowPriority:onEntered() fires for Zone A.   ","version":"Next","tagName":"h3"},{"title":"Handling State​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#handling-state","content":" You can toggle an observer's activity state. This is useful for disabling triggers during cutscenes or rounds.  observer:setEnabled(false) -- Fires 'onExited' for everyone inside task.wait(5) observer:setEnabled(true) -- Fires 'onEntered' if they are still there   ","version":"Next","tagName":"h3"},{"title":"Utility​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#utility","content":" ","version":"Next","tagName":"h2"},{"title":"Frame Budget​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#frame-budget","content":" QuickZone uses a scheduler to prevent lag. You can adjust how much time (in seconds) it is allowed to use per frame.  -- Allow 0.5 milliseconds per frame (default is 1ms) QuickZone:setFrameBudget(0.5/1000)   ","version":"Next","tagName":"h3"},{"title":"Spatial Queries​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#spatial-queries","content":" Perform instant checks without using the Observer/Group pattern.  -- Get all zones at a specific vector local zones = QuickZone:getZonesAtPoint(Vector3.new(10, 5, 0)) -- Get the group an entity belongs to local group = QuickZone:getGroupOfEntity(workspace.Part)   ","version":"Next","tagName":"h3"},{"title":"Debugging​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#debugging","content":" Enable the visualizer to see zone boundaries and whether they are used or not.  QuickZone:visualize(true)   ","version":"Next","tagName":"h3"},{"title":"Considerations​","type":1,"pageTitle":"Usage","url":"/QuickZone/docs/usage#considerations","content":" Point-Based Tracking: QuickZone tracks points (the center of a Part, the Attachment's position, etc.), not the volume of the part itself.Attachments: If you need to track a specific part of a character, add an Attachment to that part and track the Attachment.Scheduling: To maintain high FPS, QuickZone uses frame budget and smears workload across frames. As a consequence, an entity entering a zone might be detected a few frames later if thousands of calculations are queued. ","version":"Next","tagName":"h2"},{"title":"Why use QuickZone?","type":0,"sectionRef":"#","url":"/QuickZone/docs/why-use-quickzone","content":"","keywords":"","version":"Next"},{"title":"The QuickZone Approach​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#the-quickzone-approach","content":" QuickZone bypasses the physics engine in favor of geometric math and data-oriented design. It implements a Linear BVH that resolves spatial queries using math compiled to machine code to bypass interpreter overhead.  ","version":"Next","tagName":"h2"},{"title":"1. The Entity-Centric Model​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#1-the-entity-centric-model","content":" Traditional libraries are Zone-Centric. They iterate through every Zone instance and query the physics engine for overlapping parts (i.e. entities in QuickZone-terms).  The Scaling Problem: Performance worsens as you add more zones (O(Z)), even if the number of entities remains static.  QuickZone, on the other hand, is Entity-Centric. It keeps a list of entities and queries them against an LBVH (O(N log Z)).  The Benefit: This means that you can have hundreds, even thousands, of zones with very low runtime cost. The cost effectively becomes a factor of the number of entities that are being tracked.  ","version":"Next","tagName":"h3"},{"title":"2. Data-Oriented Design​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#2-data-oriented-design","content":" QuickZone is built on Data-Oriented principles, shifting the focus from 'objects' to how data is laid out in memory.  Contiguous Arrays: Unlike standard OOP where data is scattered across the heap in different objects, QuickZone stores entity data in pre-allocated, contiguous arrays. This maximizes CPU cache locality, improving processing speed. Stable Memory: By using flat arrays and object pooling, QuickZone generates almost no garbage during runtime. This prevents lag spikes caused by the GC.  ","version":"Next","tagName":"h3"},{"title":"3. Architecture​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#3-architecture","content":" QuickZone moves away from binding logic to specific Instances. Instead, it uses a topology of Groups and Observers which separates what is being tracked from where it is being tracked and how to react to that.  Groups​  A Group is a collection of entities that share performance characteristics and logical categorization.  Performance can be configured per Group, allowing for granular optimization like this:  CameraGroup: Real-time frequency (60Hz), zero tolerance. PlayerGroup: High frequency (30Hz), high precision. NPCGroup: Low frequency (2Hz), low precision.  This prevents 'wasting' CPU cycles checking a slow-moving NPC, for example.  Observers​  An Observer is a system that bridges Groups and Zones.  Observers subscribe to specific Groups. Zones (the 'where') attach to specific Observers.  This creates a Many-to-Many relationship that allows for fast and decoupled logic.  -- Create an Observer and subscribe to a group local safeObserver = QuickZone.Observer() safeObserver:subscribe(QuickZone.LocalPlayerGroup()) -- Logic is defined once, not per zone safeObserver:onEntered(function(player, zone) print('Entered Safe Zone:', zone:getId()) end) -- Create Zones from parts and attach them to the observer for _, part in workspace.SafeZones:GetChildren() do if part:IsA('BasePart') then local zone = QuickZone.ZoneFromPart(part) zone:attach(safeObserver) end end   ","version":"Next","tagName":"h3"},{"title":"4. The Budgeted Scheduler​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#4-the-budgeted-scheduler","content":" A common issue with spatial libraries is stutter due to it processing too many things in one frame. QuickZone fixes this via its smart Scheduler.  Frame Budgeting​  You can set a hard time limit (e.g., 1ms). The Scheduler monitors os.clock() in real-time. If the budget is met, the system pauses immediately and resumes in the next frame. This guarantees that QuickZone will never be the cause of a frame drop.  Workload Smearing​  The scheduler smears updates across frames. This means that, if you have a Group of 600 entities updating at 10Hz, QuickZone will process exactly 100 entities per frame at 60 fps. This ensures that we have flat, predictable performance profile with no peaks or valleys.  No starvation​  The Scheduler uses a Round-Robin strategy for Group processing. Instead of processing groups in order, QuickZone cycles through them fairly. This prevents the issue where a heavy group keeps consuming the entire frame budget and 'starving' the subsequent groups.  ","version":"Next","tagName":"h3"},{"title":"5. Flexibility​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#5-flexibility","content":" Because QuickZone relies on pure math rather than the Physics engine, it is not limited to BaseParts. It also supports duck typing for entities.  BaseParts: Uses .Position. Models: Uses .PrimaryPart.Position or :GetPivot() (if .PrimaryPart does not exist). Attachments/Bones: Uses .WorldPosition. Cameras: Uses .CFrame.Position. Tables: Uses any custom .Position, .WorldPosition and .CFrame field, or :GetPivot().  This allows you to track real-time simulations (e.g. a spell cast or an RC car) without the overhead of creating physical Instances.  ","version":"Next","tagName":"h3"},{"title":"6. Performance Benchmarks​","type":1,"pageTitle":"Why use QuickZone?","url":"/QuickZone/docs/why-use-quickzone#6-performance-benchmarks","content":" In a scenario with 2,000 moving entities and 100 zones, recorded over 30-seconds, I obtained the following benchmarks:  Metric\tQuickZone\tZonePlus\tSimpleZone\tQuickBounds\tEmpty ScriptFPS\t42.37\t37.23\t29.88\t41.31\t42.73 Events/s\t2271\t2482\t2518\t566\t0 Memory Usage (MB)\t2.13\t159\t1.77\t2.60\t1.04  Note: For the QuickZone benchmark, we used a frame budget of 1ms, the entities' update rate was set to 60Hz, and the precision was 0.0.  The benchmarks show that QuickZone's negative impact on FPS was quite negligible compared to the empty script baseline. In comparison, ZonePlus drops the game to ~29 FPS under the same load, introducing significant stutter, while SimpleZone drops frames by ~13%. QuickZone proves that you can run complex spatial logic without taxing the render loop.  Furthermore, QuickZone only used 2.13 MB of memory. In comparison, ZonePlus bloats to 159 MB. QuickZone's use of flat arrays and object pooling keeps the memory footprint ~98% smaller.  While QuickBounds has similar, if not slightly worse, FPS and memory usage, QuickZone handles 4x the event volume (2271 vs 566 events/s). This validates the shift to the Linear BVH, contiguous arrays, caching, and starvation prevention techniques, allowing the system to process thousands of spatial queries per second without bottlenecking the CPU. ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}