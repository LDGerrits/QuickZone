"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[304],{7580:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"why-use-quickzone","title":"Why use QuickZone?","description":"Traditional zone libraries like ZonePlus and SimpleZone act as wrappers for Roblox\'s internal physics queries. Such libraries may use basic Bounding Volume Hierarchy (BVHs), but ultimately rely on the physics engine (e.g., GetBoundsInBox, GetPartsInPart or .Touched), resulting in expensive collision geometry calculations and synchronization overhead.","source":"@site/docs/why-use-quickzone.md","sourceDirName":".","slug":"/why-use-quickzone","permalink":"/QuickZone/docs/why-use-quickzone","draft":false,"unlisted":false,"editUrl":"https://github.com/LDgerrits/QuickZone/edit/main/docs/why-use-quickzone.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"defaultSidebar","previous":{"title":"Usage","permalink":"/QuickZone/docs/usage"}}');var r=s(4848),t=s(8453);const o={sidebar_position:3},a="Why use QuickZone?",c={},l=[{value:"The QuickZone Approach",id:"the-quickzone-approach",level:2},{value:"1. The Entity-Centric Model",id:"1-the-entity-centric-model",level:3},{value:"2. Data-Oriented Design",id:"2-data-oriented-design",level:3},{value:"3. Architecture",id:"3-architecture",level:3},{value:"Groups",id:"groups",level:4},{value:"Observers",id:"observers",level:4},{value:"4. The Budgeted Scheduler",id:"4-the-budgeted-scheduler",level:3},{value:"Frame Budgeting",id:"frame-budgeting",level:4},{value:"Workload Smearing",id:"workload-smearing",level:4},{value:"No starvation",id:"no-starvation",level:4},{value:"5. Flexibility",id:"5-flexibility",level:3},{value:"6. Performance Benchmarks",id:"6-performance-benchmarks",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"why-use-quickzone",children:"Why use QuickZone?"})}),"\n",(0,r.jsxs)(n.p,{children:["Traditional zone libraries like ZonePlus and SimpleZone act as wrappers for Roblox's internal physics queries. Such libraries may use basic Bounding Volume Hierarchy (BVHs), but ultimately rely on the physics engine (e.g., ",(0,r.jsx)(n.code,{children:"GetBoundsInBox"}),", ",(0,r.jsx)(n.code,{children:"GetPartsInPart"})," or ",(0,r.jsx)(n.code,{children:".Touched"}),"), resulting in expensive collision geometry calculations and synchronization overhead."]}),"\n",(0,r.jsx)(n.h2,{id:"the-quickzone-approach",children:"The QuickZone Approach"}),"\n",(0,r.jsx)(n.p,{children:"QuickZone bypasses the physics engine in favor of geometric math and data-oriented design. It implements a Linear BVH that resolves spatial queries using math compiled to machine code to bypass interpreter overhead."}),"\n",(0,r.jsx)(n.h3,{id:"1-the-entity-centric-model",children:"1. The Entity-Centric Model"}),"\n",(0,r.jsx)(n.p,{children:"Traditional libraries are Zone-Centric. They iterate through every Zone instance and query the physics engine for overlapping parts (i.e. entities in QuickZone-terms)."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"The Scaling Problem"}),": Performance worsens as you add more zones (",(0,r.jsx)(n.em,{children:"O(Z)"}),"), even if the number of entities remains static."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["QuickZone, on the other hand, is Entity-Centric. It keeps a list of entities and queries them against an LBVH (",(0,r.jsx)(n.em,{children:"O(N log Z)"}),")."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"The Benefit"}),": This means that you can have hundreds, even thousands, of zones with very low runtime cost. The cost effectively becomes a factor of the number of entities that are being tracked."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-data-oriented-design",children:"2. Data-Oriented Design"}),"\n",(0,r.jsx)(n.p,{children:"QuickZone is built on Data-Oriented principles, shifting the focus from 'objects' to how data is laid out in memory."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Contiguous Arrays"}),": Unlike standard OOP where data is scattered across the heap in different objects, QuickZone stores entity data in pre-allocated, contiguous arrays. This maximizes CPU cache locality, improving processing speed."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Stable Memory"}),": By using flat arrays and object pooling, QuickZone generates almost no garbage during runtime. This prevents lag spikes caused by the GC."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-architecture",children:"3. Architecture"}),"\n",(0,r.jsx)(n.p,{children:"QuickZone moves away from binding logic to specific Instances. Instead, it uses a topology of Groups and Observers which separates what is being tracked from where it is being tracked and how to react to that."}),"\n",(0,r.jsx)(n.h4,{id:"groups",children:"Groups"}),"\n",(0,r.jsx)(n.p,{children:"A Group is a collection of entities that share performance characteristics and logical categorization."}),"\n",(0,r.jsx)(n.p,{children:"Performance can be configured per Group, allowing for granular optimization like this:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"CameraGroup"}),": Real-time frequency (60Hz), zero tolerance."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"PlayerGroup"}),": High frequency (30Hz), high precision."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"NPCGroup"}),": Low frequency (2Hz), low precision."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This prevents 'wasting' CPU cycles checking a slow-moving NPC, for example."}),"\n",(0,r.jsx)(n.h4,{id:"observers",children:"Observers"}),"\n",(0,r.jsx)(n.p,{children:"An Observer is a system that bridges Groups and Zones."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Observers subscribe to specific Groups."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Zones (the 'where') attach to specific Observers."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This creates a Many-to-Many relationship that allows for fast and decoupled logic."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"-- Create an Observer and subscribe to a group\nlocal safeObserver = QuickZone.Observer()\nsafeObserver:subscribe(QuickZone.LocalPlayerGroup())\n\n-- Logic is defined once, not per zone\nsafeObserver:onEntered(function(player, zone)\n    print('Entered Safe Zone:', zone:getId())\nend)\n\n-- Create Zones from parts and attach them to the observer\nfor _, part in workspace.SafeZones:GetChildren() do\n    if part:IsA('BasePart') then\n        local zone = QuickZone.ZoneFromPart(part)\n        zone:attach(safeObserver)\n    end\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-the-budgeted-scheduler",children:"4. The Budgeted Scheduler"}),"\n",(0,r.jsx)(n.p,{children:"A common issue with spatial libraries is stutter due to it processing too many things in one frame. QuickZone fixes this via its smart Scheduler."}),"\n",(0,r.jsx)(n.h4,{id:"frame-budgeting",children:"Frame Budgeting"}),"\n",(0,r.jsx)(n.p,{children:"You can set a hard time limit (e.g., 1ms). The Scheduler monitors os.clock() in real-time. If the budget is met, the system pauses immediately and resumes in the next frame. This guarantees that QuickZone will never be the cause of a frame drop."}),"\n",(0,r.jsx)(n.h4,{id:"workload-smearing",children:"Workload Smearing"}),"\n",(0,r.jsx)(n.p,{children:"The scheduler smears updates across frames. This means that, if you have a Group of 600 entities updating at 10Hz, QuickZone will process exactly 100 entities per frame at 60 fps. This ensures that we have flat, predictable performance profile with no peaks or valleys."}),"\n",(0,r.jsx)(n.h4,{id:"no-starvation",children:"No starvation"}),"\n",(0,r.jsx)(n.p,{children:"The Scheduler uses a Round-Robin strategy for Group processing. Instead of processing groups in order, QuickZone cycles through them fairly. This prevents the issue where a heavy group keeps consuming the entire frame budget and 'starving' the subsequent groups."}),"\n",(0,r.jsx)(n.h3,{id:"5-flexibility",children:"5. Flexibility"}),"\n",(0,r.jsx)(n.p,{children:"Because QuickZone relies on pure math rather than the Physics engine, it is not limited to BaseParts. It also supports duck typing for entities."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"BaseParts"}),": Uses ",(0,r.jsx)(n.code,{children:".Position"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Models"}),": Uses ",(0,r.jsx)(n.code,{children:".PrimaryPart.Position"})," or ",(0,r.jsx)(n.code,{children:":GetPivot()"})," (if ",(0,r.jsx)(n.code,{children:".PrimaryPart"})," does not exist)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Attachments/Bones"}),": Uses ",(0,r.jsx)(n.code,{children:".WorldPosition"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cameras"}),": Uses ",(0,r.jsx)(n.code,{children:".CFrame.Position"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tables"}),": Uses any custom ",(0,r.jsx)(n.code,{children:".Position"}),", ",(0,r.jsx)(n.code,{children:".WorldPosition"})," and ",(0,r.jsx)(n.code,{children:".CFrame"})," field, or ",(0,r.jsx)(n.code,{children:":GetPivot()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This allows you to track real-time simulations (e.g. a spell cast or an RC car) without the overhead of creating physical Instances."}),"\n",(0,r.jsx)(n.h3,{id:"6-performance-benchmarks",children:"6. Performance Benchmarks"}),"\n",(0,r.jsx)(n.p,{children:"In a scenario with 2,000 moving entities and 100 zones, recorded over 30-seconds, I obtained the following benchmarks:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Metric"}),(0,r.jsx)(n.th,{children:"QuickZone"}),(0,r.jsx)(n.th,{children:"ZonePlus"}),(0,r.jsx)(n.th,{children:"SimpleZone"}),(0,r.jsx)(n.th,{children:"QuickBounds"}),(0,r.jsx)(n.th,{children:"Empty Script"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"FPS"}),(0,r.jsx)(n.td,{children:"42.37"}),(0,r.jsx)(n.td,{children:"37.23"}),(0,r.jsx)(n.td,{children:"29.88"}),(0,r.jsx)(n.td,{children:"41.31"}),(0,r.jsx)(n.td,{children:"42.73"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Events/s"}),(0,r.jsx)(n.td,{children:"2271"}),(0,r.jsx)(n.td,{children:"2482"}),(0,r.jsx)(n.td,{children:"2518"}),(0,r.jsx)(n.td,{children:"566"}),(0,r.jsx)(n.td,{children:"0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Memory Usage (MB)"}),(0,r.jsx)(n.td,{children:"2.13"}),(0,r.jsx)(n.td,{children:"159"}),(0,r.jsx)(n.td,{children:"1.77"}),(0,r.jsx)(n.td,{children:"2.60"}),(0,r.jsx)(n.td,{children:"1.04"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Note: For the QuickZone benchmark, we used a frame budget of 1ms, the entities' update rate was set to 60Hz, and the precision was 0.0."})}),"\n",(0,r.jsx)(n.p,{children:"The benchmarks show that QuickZone's negative impact on FPS was quite negligible compared to the empty script baseline. In comparison, ZonePlus drops the game to ~29 FPS under the same load, introducing significant stutter, while SimpleZone drops frames by ~13%. QuickZone proves that you can run complex spatial logic without taxing the render loop."}),"\n",(0,r.jsx)(n.p,{children:"Furthermore, QuickZone only used 2.13 MB of memory. In comparison, ZonePlus bloats to 159 MB. QuickZone's use of flat arrays and object pooling keeps the memory footprint ~98% smaller."}),"\n",(0,r.jsx)(n.p,{children:"While QuickBounds has similar, if not slightly worse, FPS and memory usage, QuickZone handles 4x the event volume (2271 vs 566 events/s). This validates the shift to the Linear BVH, contiguous arrays, caching, and starvation prevention techniques, allowing the system to process thousands of spatial queries per second without bottlenecking the CPU."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);