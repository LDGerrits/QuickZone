"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[976],{7879:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"intro","title":"Introduction","description":"Overview","source":"@site/docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/QuickZone/docs/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/LDgerrits/QuickZone/edit/main/docs/intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"defaultSidebar","next":{"title":"Usage","permalink":"/QuickZone/docs/usage"}}');var s=t(4848),r=t(8453);const o={sidebar_position:1},a="Introduction",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Core Features",id:"core-features",level:2},{value:"Performance Benchmarks",id:"performance-benchmarks",level:2},{value:"Test 1: High Zone Count",id:"test-1-high-zone-count",level:3},{value:"Test 2: High Entity Count",id:"test-2-high-entity-count",level:3},{value:"Installation",id:"installation",level:2},{value:"Wally",id:"wally",level:3},{value:"Manual",id:"manual",level:3},{value:"Quick Start",id:"quick-start",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"QuickZone is a lightweight spatial library for Roblox that replaces expensive physics queries with fast, math-based entity tracking at scale. Instead of the physics engine, it uses geometric math while providing a predictable, budgeted, and flexible solution for zone detection, making it possible to track thousands of entities across hundreds of zones with very little impact on your frame rate."}),"\n",(0,s.jsxs)(n.admonition,{title:"Point-Based Detection",type:"info",children:[(0,s.jsx)(n.p,{children:"QuickZone uses point-based detection. It checks if a specific point (e.g., the center of a Part, the position of an Attachment, or the Pivot of a Model) is inside a zone's boundary."}),(0,s.jsx)(n.p,{children:"Because it calculates if it is inside or not using geometric math instead of physics-based volume intersections, it is significantly faster than other zone detection libraries."})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"core-features",children:"Core Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Lifecycle Management"}),": Use the ",(0,s.jsx)(n.code,{children:"observe"})," pattern for 100% reliable cleanup. There is no need for juggling ",(0,s.jsx)(n.code,{children:"onEntered"})," and ",(0,s.jsx)(n.code,{children:"onExited"})," events anymore (do note that QuickZone still supports Event-Driven Programming)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Track Anything"}),": Track BaseParts, Models, Attachments, Bones, Cameras, or even pure Lua tables. If it has a position, QuickZone can track it."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Shape Support"}),": Supports mathematical containment for Blocks, Balls, Cylinders, and Wedges without relying on physics collision meshes."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Decoupled Architecture"}),": Separate game logic from spatial instances. Bind behaviors to categories of entities (Players, NPCs, Projectiles) for a clean, scalable architecture."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Budgeted Scheduler"}),": Remove lag spikes by setting a hard frame budget (e.g., 1ms). Workload is smeared across frames to maintain a flat and predictable performance profile."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Zero-Allocation Runtime"}),": By using contiguous arrays and object pooling, QuickZone reduces GC pressure, avoiding memory-related stutters."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"performance-benchmarks",children:"Performance Benchmarks"}),"\n",(0,s.jsxs)(n.p,{children:["We stress-tested QuickZone against the most popular alternatives in two distinct scenarios: ",(0,s.jsx)(n.strong,{children:"Entity Stress"})," (lots of moving parts) and ",(0,s.jsx)(n.strong,{children:"Map Stress"})," (lots of zones)."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Note: For the QuickZone benchmark, we used a frame budget of 1ms, the entities' update rate was set to 60Hz, and precision was 0.0."})}),"\n",(0,s.jsx)(n.h3,{id:"test-1-high-zone-count",children:"Test 1: High Zone Count"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Scenario: 500 moving entities, 10,000 zones, recorded over 30 seconds."})}),"\n",(0,s.jsx)(n.p,{children:"This test highlights the fundamental flaw in traditional Zone-Centric libraries. As map complexity grows, their performance degrades exponentially."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Metric"}),(0,s.jsx)(n.th,{children:"QuickZone"}),(0,s.jsx)(n.th,{children:"ZonePlus"}),(0,s.jsx)(n.th,{children:"SimpleZone"}),(0,s.jsx)(n.th,{children:"QuickBounds"}),(0,s.jsx)(n.th,{children:"Empty Script"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"FPS"}),(0,s.jsx)(n.td,{children:"59.25"}),(0,s.jsx)(n.td,{children:"3.84"}),(0,s.jsx)(n.td,{children:"5.53"}),(0,s.jsx)(n.td,{children:"58.95"}),(0,s.jsx)(n.td,{children:"59.28"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Events/s"}),(0,s.jsx)(n.td,{children:"643"}),(0,s.jsx)(n.td,{children:"627"}),(0,s.jsx)(n.td,{children:"519"}),(0,s.jsx)(n.td,{children:"328"}),(0,s.jsx)(n.td,{children:"0"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Memory Usage (MB)"}),(0,s.jsx)(n.td,{children:"18.57"}),(0,s.jsx)(n.td,{children:"4230"}),(0,s.jsx)(n.td,{children:"99.79"}),(0,s.jsx)(n.td,{children:"17.62"}),(0,s.jsx)(n.td,{children:"0.65"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The Result:"})," QuickZone maintained a perfect 60 FPS."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ZonePlus and SimpleZone imploded, dropping to 3-5 FPS, making the game unplayable."}),"\n",(0,s.jsx)(n.li,{children:"ZonePlus consumed over 4 GB of memory, which would crash most mobile devices instantly."}),"\n",(0,s.jsxs)(n.li,{children:["QuickZone proved it is ",(0,s.jsx)(n.em,{children:"O(N)"})," relative to entities, not zones. You can add as many zones as you want without performance penalties."]}),"\n",(0,s.jsx)(n.li,{children:"QuickZone vs. QuickBounds: Both libraries scaled well by maintaining ~60 FPS. However, QuickZone still maintained a slight FPS lead and, more importantly, delivered double the event throughput (643 vs 328) compared to QuickBounds."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"test-2-high-entity-count",children:"Test 2: High Entity Count"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Scenario: 2,000 moving entities, 100 zones, recorded over 30 seconds."})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Metric"}),(0,s.jsx)(n.th,{children:"QuickZone"}),(0,s.jsx)(n.th,{children:"ZonePlus"}),(0,s.jsx)(n.th,{children:"SimpleZone"}),(0,s.jsx)(n.th,{children:"QuickBounds"}),(0,s.jsx)(n.th,{children:"Empty Script"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"FPS"}),(0,s.jsx)(n.td,{children:"42.37"}),(0,s.jsx)(n.td,{children:"29.88"}),(0,s.jsx)(n.td,{children:"37.23"}),(0,s.jsx)(n.td,{children:"41.31"}),(0,s.jsx)(n.td,{children:"42.73"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Events/s"}),(0,s.jsx)(n.td,{children:"2271"}),(0,s.jsx)(n.td,{children:"2482"}),(0,s.jsx)(n.td,{children:"2518"}),(0,s.jsx)(n.td,{children:"566"}),(0,s.jsx)(n.td,{children:"0"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Memory Usage (MB)"}),(0,s.jsx)(n.td,{children:"2.13"}),(0,s.jsx)(n.td,{children:"159"}),(0,s.jsx)(n.td,{children:"1.77"}),(0,s.jsx)(n.td,{children:"2.60"}),(0,s.jsx)(n.td,{children:"1.04"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The Result:"})," QuickZone is the only library that maintained near-baseline FPS (-1% impact)."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ZonePlus caused a 28% drop in framerate, rendering the game choppy."}),"\n",(0,s.jsx)(n.li,{children:"QuickZone handled the load with 98% less memory than ZonePlus."}),"\n",(0,s.jsx)(n.li,{children:"QuickZone vs. QuickBounds: QuickZone squeezes out more performance, averaging ~1 FPS higher than QuickBounds. More importantly, QuickZone processed 4x the volume of events (2,271 vs 566)."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(n.h3,{id:"wally",children:"Wally"}),"\n",(0,s.jsx)(n.p,{children:"The package name + version is"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ldgerrits/quickzone@^0.4.0\n"})}),"\n",(0,s.jsx)(n.h3,{id:"manual",children:"Manual"}),"\n",(0,s.jsxs)(n.p,{children:["Download the latest .rbxm model file from the ",(0,s.jsx)(n.a,{href:"https://github.com/LDGerrits/QuickZone/releases",children:"Releases"})," tab and drag it into ReplicatedStorage."]}),"\n",(0,s.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,s.jsx)(n.p,{children:"The following example demonstrates a 'Water Zone' system. It uses an Observer to apply swimming logic to the LocalPlayerGroup only when they are inside a specific area."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"local Players = game:GetService('Players')\nlocal ReplicatedStorage = game:GetService('ReplicatedStorage')\nlocal QuickZone = require(ReplicatedStorage.QuickZone)\n\n-- Assign the classes to local variables here if you want\nlocal Group = QuickZone.Group\nlocal Observer = QuickZone.Observer\nlocal Zone = QuickZone.Zone\n\n-- Create a LocalPlayerGroup that automatically tracks the client's character (including respawns)\nlocal myPlayer = Group.localPlayer()\n\n-- Create an observer subscribed to that group. \n-- Priority 42 ensures this logic overrides lower-priority overlaps.\nlocal swimObserver = Observer.new({ \n    priority = 42,\n    groups = { myPlayer } \n})\n\n-- Define behavior\nswimObserver:observeLocalPlayer(function()\n    local chararcter = Players.LocalPlayer.Character\n    if not character then return end\n\n    local humanoid = character:FindFirstChild(\"Humanoid\")\n    if not humanoid then return end\n    \n    -- On Enter\n    humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, true)\n    humanoid:ChangeState(Enum.HumanoidStateType.Swimming)\n\n    -- Return cleanup (On Exit)\n    return function() \n        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)\n    end)\nend)\n\n-- Create zones based on parts inside workspace.WaterParts,\n-- and attach them to the observer automatically.\n-- This uses the declarative config pattern to attach everything in one step.\nZone.fromParts(workspace.WaterParts:GetChildren(), { \n    observers = { swimObserver } \n})\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);